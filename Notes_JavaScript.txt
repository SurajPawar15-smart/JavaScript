=======================================================
JavaScript Developer Roadmap (Zero to Hero)
=======================================================

🟢 1. Basics of JavaScript (Done)

What is JavaScript? (History & Usage)

Adding JS to HTML (<script> tag, internal, external)

Variables (var, let, const)

Data Types (string, number, boolean, null, undefined, symbol, bigint)

Operators (arithmetic, assignment, comparison, logical, ternary)

Type Conversion & Coercion

🟡 2. Control Flow (Done)

Conditional Statements (if, else if, else, switch)

Loops (for, while, do...while, for...of, for...in)

Break & Continue

Error Handling (try...catch...finally, throw)

🔵 3. Functions (Done)

Function Declaration & Expression

Parameters & Arguments

Return Values

Arrow Functions () => {}

Default Parameters

Rest & Spread Operators (...)

Callback Functions

Higher-Order Functions

🟠 4. Core Concepts (Done)

Scope (Block, Function, Global)

Hoisting

Closures

The this keyword

Execution Context & Call Stack

Lexical Environment

Strict Mode ("use strict")

🟣 5. Objects & Arrays (Done)

Creating Objects ({} and new Object())

Object Methods (Object.keys, Object.values, Object.entries)

Object Destructuring

Array Methods (map, filter, reduce, forEach, find, some, every, sort)

Array & Object Spread/Rest

JSON (JSON.stringify, JSON.parse)

🔴 6. DOM Manipulation (Done)

Selecting Elements (getElementById, querySelector, querySelectorAll)

Changing Content & Styles (innerHTML, textContent, style)

Adding & Removing Elements (appendChild, remove, insertBefore)

Attributes & Classes (setAttribute, classList)

Event Handling (addEventListener, event bubbling, delegation)

🟤 7. Advanced JavaScript (Done)

ES6+ Features (let/const, template literals, destructuring, modules, etc.)

Spread & Rest Operator

Default & Named Exports / Imports

Promises (then, catch, finally)

Async/Await

Fetch API & AJAX

Event Loop & Concurrency Model

JavaScript Engine (V8 basics)

⚫ 8. Object-Oriented Programming (OOP) (Done)

Constructor Functions

Prototypes & Prototype Chain

class & extends

super & constructor

Encapsulation, Inheritance, Polymorphism

Object.create()

🔵 9. Functional Programming

Pure Functions

Immutability

First-class Functions

Higher-Order Functions

Currying & Partial Application

Composition & Pipelines

🟢 10. Browser APIs

LocalStorage & SessionStorage

Geolocation API

Fetch & API Calls

Web Workers

Canvas API

Notifications & Clipboard API

🟡 11. Asynchronous JavaScript (Deep Dive)

Callbacks

Promises (chaining)

Async/Await with try...catch

Parallel vs Sequential Execution

Promise.all, Promise.race, Promise.any

🔴 12. Advanced Topics

Event Bubbling vs Capturing

Debouncing & Throttling

Modules (ESM vs CommonJS)

Polyfills & Transpilers (Babel)

Bundlers (Webpack, Vite, Parcel)

Error Handling & Debugging (console, debugger)

🟤 13. JavaScript in Depth

Memory Management & Garbage Collection

Closures (Advanced use cases)

Currying & Memoization

Shadowing & Temporal Dead Zone (TDZ)

Design Patterns in JS (Singleton, Factory, Observer, etc.)

🟣 14. Testing in JavaScript

Unit Testing (Jest, Mocha, Jasmine)

Integration & End-to-End Testing (Cypress, Playwright)

Test-Driven Development (TDD)

⚫ 15. Type Safety & Scaling

TypeScript Basics (types, interfaces, generics)

Flow / JSDoc annotations

Large-Scale Application Structure

🟢 16. Frameworks & Libraries

React.js / Angular / Vue.js

State Management (Redux, Zustand, Vuex)

UI Libraries (Material UI, Tailwind CSS with JS)

🟡 17. Backend with JavaScript

Node.js Basics

NPM & Package Management

Express.js Framework

REST APIs & CRUD Operations

MongoDB / SQL with JS

🔴 18. Tools & Best Practices

Git & GitHub

ESLint & Prettier

Debugging Tools (Chrome DevTools)

CI/CD with JavaScript projects

Performance Optimization

🟣 19. Advanced & Expert Level

Event-Driven Architecture

WebSockets & Real-time Apps

Microservices with Node.js

GraphQL with JavaScript

Security in JS (XSS, CSRF, JWT, OAuth)

Server-Side Rendering (Next.js, Nuxt.js)

====================================================================
1.Basics of JavaScript (Done)
What is JavaScript? (History & Usage)
=================================================================
📌 What is JavaScript?

JavaScript (JS) is a high-level, interpreted programming language that makes web pages interactive, dynamic, and user-friendly.

It runs on the client side (browser) but also on the server side using environments like Node.js.

It follows the ECMAScript standard.

👉 In short:

HTML → Defines structure of a webpage.

CSS → Defines style and presentation.

JavaScript → Defines behavior (adds logic, interactivity, and dynamic content).

📜 History of JavaScript

1995 → Created by Brendan Eich at Netscape in just 10 days.

Initially called Mocha, then renamed to LiveScript, and finally JavaScript.

1997 → Standardized by ECMA International as ECMAScript (ES).

Over the years, updates like ES5 (2009), ES6/ES2015, and beyond have introduced powerful features (classes, arrow functions, async/await, modules, etc.).

⚡ Fun fact: Despite its name, JavaScript is not related to Java. The name was mainly for marketing reasons, as Java was popular at that time.

🎯 Usage of JavaScript

JavaScript is everywhere today:

Web Development

Adds interactivity to web pages.

Example: Form validation, sliders, popups, animations.

<!DOCTYPE html>
<html>
<body>
  <h2>JavaScript Example</h2>
  <button onclick="greet()">Click Me</button>

  <script>
    function greet() {
      alert("Hello! Welcome to JavaScript.");
    }
  </script>
</body>
</html>


Web Applications

Frameworks like React, Angular, Vue make Single Page Applications (SPAs).

Example: Showing current time dynamically.

<p id="time"></p>
<script>
  document.getElementById("time").innerHTML = new Date().toLocaleTimeString();
</script>


Server-Side Development

Using Node.js, JavaScript can build scalable backend applications.

// Simple Node.js server
const http = require('http');

http.createServer((req, res) => {
  res.write("Hello from Node.js!");
  res.end();
}).listen(3000);


Mobile Apps

Frameworks like React Native, Ionic allow building cross-platform apps.

Game Development

Libraries like Phaser.js let you build 2D games.

AI & Machine Learning

Libraries like TensorFlow.js enable running ML models in browsers.

✅ Summary

JavaScript is a lightweight, versatile language.

Born in 1995 at Netscape → Standardized as ECMAScript.

Used for frontend, backend, mobile apps, games, and even AI.

Today, it’s one of the core technologies of the web alongside HTML & CSS.

========================================================
Adding JS to HTML (<script> tag, internal, external)
========================================================
📌 Adding JavaScript to HTML

There are 3 main ways to include JavaScript in an HTML document:

1️⃣ Inline JavaScript (inside HTML tag)

You can write JavaScript directly inside an element’s attribute such as onclick, onmouseover, etc.

👉 Example:

<!DOCTYPE html>
<html>
<head>
  <title>Inline JavaScript Example</title>
</head>
<body>
  <button onclick="alert('Hello! Inline JS works.')">Click Me</button>
</body>
</html>


✅ Used for small snippets, but not recommended for larger projects (hard to maintain).

2️⃣ Internal JavaScript (inside <script> tag in HTML)

JavaScript is placed inside <script> tags within the HTML file.
You can put it in <head> or <body>.

👉 Example:

<!DOCTYPE html>
<html>
<head>
  <title>Internal JavaScript Example</title>
  <script>
    function greet() {
      alert("Hello from Internal JavaScript!");
    }
  </script>
</head>
<body>
  <button onclick="greet()">Click Me</button>
</body>
</html>


✅ Good for small projects or quick testing.

3️⃣ External JavaScript (separate .js file)

JavaScript code is written in a separate .js file and linked using <script src="...">.

👉 Example:

index.html
<!DOCTYPE html>
<html>
<head>
  <title>External JavaScript Example</title>
  <script src="script.js"></script>
</head>
<body>
  <button onclick="greet()">Click Me</button>
</body>
</html>

script.js
function greet() {
  alert("Hello from External JavaScript!");
}


✅ Best practice for large projects → keeps HTML and JS separate and reusable.

📌 Where to Place <script> Tag?

In <head> → JS loads before content, may block page rendering.

At end of <body> → Recommended for better performance (ensures HTML loads first).

👉 Example (best practice):

<!DOCTYPE html>
<html>
<head>
  <title>Script Placement</title>
</head>
<body>
  <h1>Welcome</h1>
  <button onclick="greet()">Click Me</button>

  <!-- JavaScript loaded after HTML -->
  <script>
    function greet() {
      alert("Best practice: Script at the bottom!");
    }
  </script>
</body>
</html>


✅ Summary

Inline → onclick="..." (quick but not recommended).

Internal → <script> ... </script> inside HTML.

External → Separate .js file linked with <script src="...">.

===============================
Variables (var, let, const)
===============================
What are Variables in JavaScript?

Variables are containers for storing data values.
In JavaScript, we can declare variables using:

var

let

const

🟢 1. var (Old way – function scoped)

Introduced in 1995 (original JS).

Function-scoped → accessible only inside the function where declared.

Can be re-declared and updated.

Gets hoisted (moved to top of scope with undefined).

👉 Example:

var name = "Suraj";
console.log(name); // Suraj

var name = "Pawar"; // Re-declared
console.log(name); // Pawar

// Function scope
function test() {
  var x = 10;
  console.log(x); // 10
}
// console.log(x); // ❌ Error (x not defined outside function)

🟡 2. let (Modern – block scoped)

Introduced in ES6 (2015).

Block-scoped → accessible only inside { }.

Can be updated, but not re-declared in the same scope.

Supports hoisting, but not initialized (gives error if used before declaration).

👉 Example:

let age = 25;
console.log(age); // 25

age = 26; // ✅ Update allowed
console.log(age); // 26

// let age = 30; ❌ Error (can't re-declare in same scope)

// Block scope
{
  let city = "Pune";
  console.log(city); // Pune
}
// console.log(city); // ❌ Error (city not accessible outside block)

🔵 3. const (Constant – block scoped)

Introduced in ES6 (2015).

Block-scoped like let.

Must be initialized at declaration.

Cannot be updated or re-declared.

👉 Example:

const country = "India";
console.log(country); // India

// country = "USA"; ❌ Error (can't change value)

// const country; ❌ Error (must initialize when declared)

// Block scope
{
  const pi = 3.14159;
  console.log(pi); // 3.14159
}
// console.log(pi); // ❌ Error (not accessible outside block)

📊 Quick Comparison Table
Feature	var	let	const
Scope	Function-scoped	Block-scoped	Block-scoped
Re-declaration	✅ Allowed	❌ Not allowed	❌ Not allowed
Update value	✅ Allowed	✅ Allowed	❌ Not allowed
Hoisting	✅ Yes (initialized as undefined)	✅ Yes (but not initialized)	✅ Yes (but not initialized)
Use case	Old code (avoid now)	Variables that change	Constants, fixed values
🎯 Example (All together)
var x = 10;
let y = 20;
const z = 30;

x = 15;   // ✅ allowed
y = 25;   // ✅ allowed
// z = 35; // ❌ Error (const can't change)

console.log(x, y, z); // 15 25 30


✅ Best Practice (Modern JS):

Use let → for variables that change.

Use const → for constants or values that don’t change.

Avoid var in new code.

====================================================================================
Data Types (string, number, boolean, null, undefined, symbol, bigint) with examples
====================================================================================
JavaScript Data Types

In JavaScript, data types are divided into two categories:

Primitive Data Types (immutable, single value)

string

number

boolean

null

undefined

symbol

bigint

Non-Primitive (Reference) Data Types

Objects, Arrays, Functions (we’ll cover later).

Here, we’ll focus on primitive types.

1️⃣ String

Represents text (characters inside quotes).

Can use "double", 'single', or `` backticks (template literals).

👉 Example:

let firstName = "Suraj";   // double quotes
let lastName = 'Pawar';    // single quotes
let fullName = `${firstName} ${lastName}`; // template literal

console.log(fullName); // Suraj Pawar
console.log(typeof fullName); // string

2️⃣ Number

Represents integers, decimals, or floating-point numbers.

Special values: Infinity, -Infinity, NaN (Not a Number).

👉 Example:

let age = 25;
let price = 99.99;
let infinityValue = Infinity;
let notNumber = "abc" / 2; // NaN

console.log(age, price); // 25 99.99
console.log(typeof price); // number
console.log(notNumber); // NaN

3️⃣ Boolean

Represents true or false values.

Often used in conditions and logic.

👉 Example:

let isStudent = true;
let isWorking = false;

console.log(isStudent); // true
console.log(typeof isWorking); // boolean

4️⃣ Null

Represents an intentional empty value (nothing).

Type is "object" (this is a long-standing JavaScript bug).

👉 Example:

let data = null;
console.log(data); // null
console.log(typeof data); // object (weird but true)

5️⃣ Undefined

A variable declared but not assigned a value.

👉 Example:

let city;
console.log(city); // undefined
console.log(typeof city); // undefined

6️⃣ Symbol (ES6)

Used to create unique identifiers.

Even if symbols have the same description, they are different.

👉 Example:

let sym1 = Symbol("id");
let sym2 = Symbol("id");

console.log(sym1 === sym2); // false
console.log(typeof sym1);   // symbol

7️⃣ BigInt (ES11 / ES2020)

Used for very large integers beyond Number.MAX_SAFE_INTEGER (2^53 - 1).

Add n at the end of the number.

👉 Example:

let bigNumber = 123456789012345678901234567890n;
let normalNumber = 100;

console.log(bigNumber); 
console.log(typeof bigNumber); // bigint

📊 Summary Table
Data Type	Example	typeof result
String	"Hello"	string
Number	42, 3.14, NaN	number
Boolean	true, false	boolean
Null	null	object (bug)
Undefined	let x;	undefined
Symbol	Symbol("id")	symbol
BigInt	12345678901234567890n	bigint

⚡ Real-World Example (Mixing Data Types):

let userName = "Suraj";     // string
let userAge = 25;           // number
let isAdmin = false;        // boolean
let profilePic = null;      // null
let phone;                  // undefined
let id = Symbol("userID");  // symbol
let bigID = 987654321987654321n; // bigint

console.log(typeof userName); // string
console.log(typeof userAge);  // number
console.log(typeof isAdmin);  // boolean
console.log(typeof profilePic); // object
console.log(typeof phone);    // undefined
console.log(typeof id);       // symbol
console.log(typeof bigID);    // bigint

====================================================================
Operators (arithmetic, assignment, comparison, logical, ternary)
====================================================================
JavaScript Operators

Operators are special symbols used to perform operations on values and variables.
Main categories:

Arithmetic Operators

Assignment Operators

Comparison Operators

Logical Operators

Ternary Operator (Conditional)

1️⃣ Arithmetic Operators

Used for mathematical calculations.

Operator	Description	Example (a = 10, b = 3)	Result
+	Addition	a + b	13
-	Subtraction	a - b	7
*	Multiplication	a * b	30
/	Division	a / b	3.333…
%	Modulus (remainder)	a % b	1
**	Exponentiation	a ** b	1000
++	Increment (add 1)	a++ → 11	
--	Decrement (subtract 1)	b-- → 2	

👉 Example:

let a = 10, b = 3;

console.log(a + b); // 13
console.log(a - b); // 7
console.log(a * b); // 30
console.log(a / b); // 3.333...
console.log(a % b); // 1
console.log(a ** b); // 1000

2️⃣ Assignment Operators

Used to assign values.

Operator	Description	Example (x = 5)	Result
=	Assign	x = 5	5
+=	Add and assign	x += 2	7
-=	Subtract and assign	x -= 2	3
*=	Multiply and assign	x *= 2	10
/=	Divide and assign	x /= 2	2.5
%=	Modulus and assign	x %= 2	1

👉 Example:

let x = 5;
x += 3;  // x = 8
x *= 2;  // x = 16
console.log(x); // 16

3️⃣ Comparison Operators

Used to compare values (return true/false).

Operator	Description	Example (a = 5, b = "5", c = 10)	Result
==	Equal (value only)	a == b	true
===	Strict equal (value + type)	a === b	false
!=	Not equal (value only)	a != c	true
!==	Strict not equal	a !== b	true
>	Greater than	c > a	true
<	Less than	a < c	true
>=	Greater than or equal	a >= 5	true
<=	Less than or equal	a <= 4	false

👉 Example:

let a = 5, b = "5", c = 10;

console.log(a == b);  // true
console.log(a === b); // false
console.log(a != c);  // true
console.log(c > a);   // true

4️⃣ Logical Operators

Used for conditions (return true/false).

Operator	Description	Example (x = true, y = false)	Result
&&	Logical AND	x && y	false
||	Logical OR	`x	
!	Logical NOT	!x	false

👉 Example:

let x = true, y = false;

console.log(x && y); // false
console.log(x || y); // true
console.log(!x);     // false

5️⃣ Ternary Operator (? :)

A shorthand for if-else.

👉 Syntax:

condition ? valueIfTrue : valueIfFalse;


👉 Example:

let age = 18;
let result = (age >= 18) ? "Eligible to vote" : "Not eligible";
console.log(result); // Eligible to vote

✅ Quick Summary

Arithmetic → + - * / % ** ++ --

Assignment → = += -= *= /= %=

Comparison → == === != !== > < >= <=

Logical → && || !

Ternary → condition ? trueValue : falseValue

========================================
Type Conversion & Coercion
========================================
Type Conversion vs Type Coercion

Type Conversion (Explicit Casting)
→ You manually convert a value from one type to another using built-in functions (Number(), String(), Boolean()).

Type Coercion (Implicit Casting)
→ JavaScript automatically converts data types when different types are used together (behind the scenes).

1️⃣ Type Conversion (Explicit)

You decide how to convert the type.

👉 Example 1: String → Number

let str = "123";
let num = Number(str);

console.log(num); // 123
console.log(typeof num); // number


👉 Example 2: Number → String

let age = 25;
let strAge = String(age);

console.log(strAge); // "25"
console.log(typeof strAge); // string


👉 Example 3: Truthy/Falsy → Boolean

console.log(Boolean(1));      // true
console.log(Boolean(0));      // false
console.log(Boolean("hello"));// true
console.log(Boolean(""));     // false
console.log(Boolean(null));   // false


👉 Example 4: Parse methods

let strNum = "50.75";
console.log(parseInt(strNum));   // 50
console.log(parseFloat(strNum)); // 50.75

2️⃣ Type Coercion (Implicit)

JavaScript automatically converts data types depending on context.

👉 Example 1: String + Number → String

console.log("5" + 2); // "52" (number coerced to string)


👉 Example 2: Number - String → Number

console.log("5" - 2); // 3 (string coerced to number)
console.log("5" * "2"); // 10


👉 Example 3: Boolean coercion in operations

console.log(true + 1);  // 2  (true → 1)
console.log(false + 1); // 1  (false → 0)


👉 Example 4: Equality operators (== vs ===)

console.log(5 == "5");  // true  (coercion: "5" → 5)
console.log(5 === "5"); // false (strict: no coercion)

⚡ Special Cases of Coercion
console.log("" + 1);    // "1"   (string coercion)
console.log("5" - 1);   // 4     (number coercion)
console.log(null + 1);  // 1     (null → 0)
console.log(undefined + 1); // NaN (undefined → NaN)

📊 Summary Table
Value	Number(value)	String(value)	Boolean(value)
"123"	123	"123"	true
"abc"	NaN	"abc"	true
true	1	"true"	true
false	0	"false"	false
null	0	"null"	false
undefined	NaN	"undefined"	false
"" (empty)	0	""	false

✅ Key Takeaway

Type Conversion → Explicit, you control it (Number("5")).

Type Coercion → Implicit, JS does it automatically ("5" - 2 → 3).

======================================================================
2. Control Flow (Done)
Conditional Statements (if, else if, else, switch) with best examples
======================================================================
. if Statement

Executes a block of code if the condition is true.

👉 Example:

let age = 20;

if (age >= 18) {
  console.log("You are eligible to vote.");
}


✅ Output → You are eligible to vote.

📌 2. if ... else Statement

Provides an alternative block if the condition is false.

👉 Example:

let isLoggedIn = false;

if (isLoggedIn) {
  console.log("Welcome back, User!");
} else {
  console.log("Please log in first.");
}


✅ Output → Please log in first.

📌 3. if ... else if ... else Ladder

Used when you need to test multiple conditions.

👉 Example:

let marks = 75;

if (marks >= 90) {
  console.log("Grade: A+");
} else if (marks >= 75) {
  console.log("Grade: A");
} else if (marks >= 50) {
  console.log("Grade: B");
} else {
  console.log("Grade: Fail");
}


✅ Output → Grade: A

📌 4. switch Statement

Used when you want to compare the same variable with multiple values.

Cleaner than multiple else if statements.

Uses case and requires break to stop execution.

👉 Example:

let day = 3;
let dayName;

switch (day) {
  case 1:
    dayName = "Monday";
    break;
  case 2:
    dayName = "Tuesday";
    break;
  case 3:
    dayName = "Wednesday";
    break;
  case 4:
    dayName = "Thursday";
    break;
  case 5:
    dayName = "Friday";
    break;
  case 6:
    dayName = "Saturday";
    break;
  case 7:
    dayName = "Sunday";
    break;
  default:
    dayName = "Invalid day";
}
console.log(dayName);


✅ Output → Wednesday

📊 Quick Comparison
Statement	Use Case
if	Single condition
if...else	Two-way choice
else if	Multiple conditions
switch	Multiple fixed values for a single variable
⚡ Real-World Example (Login System)
let role = "admin";

if (role === "admin") {
  console.log("Access granted: You can manage everything.");
} else if (role === "editor") {
  console.log("Access granted: You can edit content.");
} else if (role === "user") {
  console.log("Access granted: You can view content.");
} else {
  console.log("Access denied: Unknown role.");
}


✅ Output → Access granted: You can manage everything.


=======================================================
Loops (for, while, do...while, for...of, for...in)
=======================================================
. for Loop

Used when you know how many times you want to repeat something.

👉 Example: Print numbers 1 to 5

for (let i = 1; i <= 5; i++) {
  console.log("Number:", i);
}


✅ Output:

Number: 1  
Number: 2  
Number: 3  
Number: 4  
Number: 5  

📌 2. while Loop

Executes code while a condition is true.
Used when you don’t know the exact number of iterations in advance.

👉 Example: Print numbers 1 to 5

let i = 1;
while (i <= 5) {
  console.log("While Loop:", i);
  i++;
}

📌 3. do...while Loop

Like while, but ensures the block runs at least once, even if the condition is false.

👉 Example: Run at least once

let j = 6;
do {
  console.log("Do While Loop:", j);
  j++;
} while (j <= 5);


✅ Output:

Do While Loop: 6


(Even though condition was false, it ran once.)

📌 4. for...of Loop

Used to iterate over arrays, strings, or other iterable objects.

👉 Example: Loop through array

let fruits = ["Apple", "Banana", "Mango"];

for (let fruit of fruits) {
  console.log("Fruit:", fruit);
}


✅ Output:

Fruit: Apple  
Fruit: Banana  
Fruit: Mango  


👉 Example: Loop through string

let word = "JS";

for (let char of word) {
  console.log("Character:", char);
}


✅ Output:

Character: J  
Character: S  

📌 5. for...in Loop

Used to iterate over object properties (keys).

👉 Example: Loop through object

let user = { name: "Suraj", age: 25, country: "India" };

for (let key in user) {
  console.log(key, ":", user[key]);
}


✅ Output:

name : Suraj  
age : 25  
country : India  

📊 Quick Comparison
Loop Type	Best Use Case
for	Known number of iterations
while	Unknown number of iterations (runs while condition is true)
do...while	Run at least once, then check condition
for...of	Iterate over arrays, strings, sets, maps
for...in	Iterate over object keys
⚡ Real-World Example: Shopping Cart
let cart = [
  { item: "Book", price: 200 },
  { item: "Pen", price: 50 },
  { item: "Bag", price: 500 }
];

let total = 0;
for (let product of cart) {
  total += product.price;
}
console.log("Total Price:", total);


✅ Output → Total Price: 750

============================================
Break & Continue
============================================
1. break Statement

👉 Used to exit a loop completely when a condition is met.

📌 Example: Stop searching after finding an item in stock
let products = ["Laptop", "Phone", "Tablet", "Camera"];
let search = "Tablet";

for (let item of products) {
  console.log("Checking:", item);

  if (item === search) {
    console.log("✅ Found:", item);
    break; // Exit the loop
  }
}


✅ Output:

Checking: Laptop  
Checking: Phone  
Checking: Tablet  
✅ Found: Tablet


👉 The loop stops after finding Tablet.

🔹 2. continue Statement

👉 Used to skip the current iteration and move to the next one.

📌 Example: Skip out-of-stock items in a shopping cart
let cart = [
  { item: "Book", stock: true },
  { item: "Pen", stock: false },
  { item: "Bag", stock: true }
];

for (let product of cart) {
  if (!product.stock) {
    console.log("⛔ Skipping:", product.item);
    continue; // Skip this product
  }
  console.log("🛒 Adding to cart:", product.item);
}


✅ Output:

🛒 Adding to cart: Book  
⛔ Skipping: Pen  
🛒 Adding to cart: Bag  


👉 The loop skips the Pen since stock is false.

🔹 3. Real-Life Example: Login Attempts (using break)
let correctPassword = "12345";
let attempts = ["11111", "22222", "12345", "44444"];

for (let attempt of attempts) {
  if (attempt === correctPassword) {
    console.log("🔐 Login Successful!");
    break; // Stop checking after correct password
  }
  console.log("❌ Wrong Password:", attempt);
}


✅ Output:

❌ Wrong Password: 11111  
❌ Wrong Password: 22222  
🔐 Login Successful!

🔹 4. Real-Life Example: Skipping Invalid Emails (using continue)
let emails = ["test@gmail.com", "", "user@yahoo.com", null, "admin@site.com"];

for (let email of emails) {
  if (!email) {
    console.log("⚠️ Invalid email, skipping...");
    continue; // Skip empty/null emails
  }
  console.log("📩 Sending mail to:", email);
}


✅ Output:

📩 Sending mail to: test@gmail.com  
⚠️ Invalid email, skipping...  
📩 Sending mail to: user@yahoo.com  
⚠️ Invalid email, skipping...  
📩 Sending mail to: admin@site.com  


✨ Quick Summary

break → Exit the loop immediately.

continue → Skip current iteration, continue with the next.

============================================
Error Handling (try...catch...finally, throw)
============================================
JavaScript provides:

try...catch → To handle runtime errors.

finally → Runs cleanup code regardless of success/failure.

throw → Used to create custom errors.

Let’s see real-world best examples 👇

🔹 1. Basic try...catch

👉 Prevent app crash when error occurs.

try {
  let user = JSON.parse('{"name":"Suraj", "age":25}');
  console.log("✅ User loaded:", user.name);
} catch (error) {
  console.log("❌ Failed to parse user data:", error.message);
}


✅ Output:

✅ User loaded: Suraj


If JSON was invalid → ❌ Failed to parse user data: Unexpected token ...

🔹 2. finally (Cleanup Always Runs)

👉 Example: Closing DB connection or loader spinner.

function fetchData() {
  try {
    console.log("⏳ Fetching data...");
    throw new Error("Server not responding!");
  } catch (error) {
    console.log("❌ Error:", error.message);
  } finally {
    console.log("🔄 Closing connection / Hiding loader...");
  }
}

fetchData();


✅ Output:

⏳ Fetching data...  
❌ Error: Server not responding!  
🔄 Closing connection / Hiding loader...

🔹 3. throw (Custom Errors)

👉 Example: Validate form input.

function registerUser(name, age) {
  try {
    if (!name) throw new Error("Name is required!");
    if (age < 18) throw new Error("User must be 18+ to register.");

    console.log(`✅ Registered: ${name}, Age: ${age}`);
  } catch (error) {
    console.log("⚠️ Registration failed:", error.message);
  }
}

registerUser("Suraj", 25);   // Works
registerUser("", 20);        // Error: Name is required
registerUser("Ravi", 15);    // Error: Must be 18+


✅ Output:

✅ Registered: Suraj, Age: 25  
⚠️ Registration failed: Name is required!  
⚠️ Registration failed: User must be 18+ to register.

🔹 4. Real-Life Example: API Call with try...catch

👉 Handling API fetch errors.

async function getUsers() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/users");

    if (!response.ok) {
      throw new Error("Failed to fetch users!");
    }

    let data = await response.json();
    console.log("✅ Users:", data);
  } catch (error) {
    console.log("❌ API Error:", error.message);
  } finally {
    console.log("🔄 API call completed!");
  }
}

getUsers();


✅ Handles cases like no internet, wrong URL, or server errors.

🔹 5. Nested try...catch Example

👉 Example: Payment process (card check → transaction).

function processPayment(card, amount) {
  try {
    if (!card) throw new Error("Card not found!");

    try {
      if (amount <= 0) throw new Error("Invalid amount!");
      console.log(`✅ Payment of $${amount} successful.`);
    } catch (err) {
      console.log("⚠️ Transaction failed:", err.message);
    }

  } catch (err) {
    console.log("❌ Payment error:", err.message);
  } finally {
    console.log("🔄 Closing payment session...");
  }
}

processPayment("Visa", 100);   // Works  
processPayment("Visa", 0);     // Transaction failed  
processPayment("", 200);       // Card not found  


✅ Summary Table

Statement	Purpose
try	Test a block of code.
catch	Handle error if occurs.
finally	Always runs (cleanup).
throw	Create a custom error.

============================================================
3. Functions
Function Declaration & Expression
============================================================
In JavaScript, functions are building blocks. There are mainly two common ways to define them:

Function Declaration

Function Expression

Let’s go step by step with examples 👇

🔹 1. Function Declaration

👉 A named function defined using the function keyword.

Can be called before or after its definition (hoisting).

📌 Example: Greeting Function
// Function Declaration
function greet(name) {
  return `Hello, ${name}! 👋`;
}

console.log(greet("Suraj")); // ✅ Can call here also


✅ Output:

Hello, Suraj! 👋


👉 Key Point: Function Declarations are hoisted (moved to the top of scope automatically).

🔹 2. Function Expression

👉 A function assigned to a variable (anonymous or named).

Not hoisted → must be defined before use.

📌 Example: Sum Function
// Function Expression
const sum = function(a, b) {
  return a + b;
};

console.log(sum(5, 10)); // ✅ Must call after definition


✅ Output:

15

🔹 Differences (Declaration vs Expression)
Feature	Function Declaration	Function Expression
Hoisting	✅ Yes (can call before defining)	❌ No (must define first)
Name	Always has a name	Can be anonymous or named
Usage	For reusable named functions	For callbacks, dynamic use
Syntax	function myFunc(){}	const myFunc = function(){}
🔹 3. Real-Life Examples
✅ Function Declaration (Login check)
function checkLogin(username, password) {
  return username === "admin" && password === "12345";
}

console.log(checkLogin("admin", "12345")); // true
console.log(checkLogin("guest", "12345")); // false

✅ Function Expression (Button click handler)
const handleClick = function() {
  console.log("🔘 Button clicked!");
};

// Imagine attaching this in HTML button
// <button onclick="handleClick()">Click Me</button>

handleClick(); // Works like an event callback


⚡ Bonus: Arrow Functions (a shorthand of Function Expression)

const multiply = (x, y) => x * y;
console.log(multiply(4, 5)); // 20

============================================================
Parameters & Arguments
============================================================
In JavaScript, parameters and arguments are related but not the same:

🔹 Parameters vs Arguments

Parameters → Variables defined in the function declaration (placeholders).

Arguments → Actual values passed when calling the function.

👉 Think of it like this:

Parameters = Empty slots.

Arguments = The actual data you put in those slots.

🔹 Example 1: Simple Function
// Parameters: name, age
function introduce(name, age) {
  console.log(`Hello, my name is ${name} and I am ${age} years old.`);
}

// Arguments: "Suraj", 25
introduce("Suraj", 25);


✅ Output:

Hello, my name is Suraj and I am 25 years old.

🔹 Example 2: Real-Life Shopping Cart
// Parameters: item, price, quantity
function addToCart(item, price, quantity) {
  let total = price * quantity;
  console.log(`🛒 Added ${quantity} ${item}(s). Total = ₹${total}`);
}

// Arguments: "Book", 200, 3
addToCart("Book", 200, 3);


✅ Output:

🛒 Added 3 Book(s). Total = ₹600

🔹 Example 3: Default Parameters

👉 You can give default values to parameters if no arguments are passed.

function greetUser(name = "Guest") {
  console.log(`Welcome, ${name}!`);
}

greetUser("Suraj"); // Argument: "Suraj"
greetUser();        // No argument → uses default


✅ Output:

Welcome, Suraj!
Welcome, Guest!

🔹 Example 4: Rest Parameters (...)

👉 Used when number of arguments is unknown.

function calculateTotal(...prices) {
  let sum = 0;
  for (let price of prices) {
    sum += price;
  }
  console.log("💰 Total Price:", sum);
}

// Multiple arguments
calculateTotal(200, 150, 50, 100);


✅ Output:

💰 Total Price: 500

🔹 Example 5: Real-Life — Sending Email
function sendEmail(to, subject, message = "No message") {
  console.log(`📧 Email sent to: ${to}`);
  console.log(`   Subject: ${subject}`);
  console.log(`   Message: ${message}`);
}

// Passing arguments
sendEmail("user@gmail.com", "Welcome!", "Thanks for joining us.");
sendEmail("admin@gmail.com", "Alert"); // message uses default


✅ Output:

📧 Email sent to: user@gmail.com
   Subject: Welcome!
   Message: Thanks for joining us.
📧 Email sent to: admin@gmail.com
   Subject: Alert
   Message: No message


✅ Summary Table

Term	Meaning
Parameters	Placeholders inside function definition (function(x, y))
Arguments	Actual values passed (myFunc(5, 10))
Default Parameters	Provide fallback values
Rest Parameters	Handle unlimited arguments

============================================================
Return Values
============================================================
In JavaScript, functions can return values using the return keyword. The return statement:

Sends a value back to the caller.

Ends function execution immediately.

Can return any data type (string, number, object, array, function, etc.).

🔹 1. Basic Return Example
function add(a, b) {
  return a + b; // returning result
}

let sum = add(5, 10);
console.log("✅ Sum is:", sum);


✅ Output:

✅ Sum is: 15

🔹 2. Real-Life Example: Discount Calculation
function calculateDiscount(price, discountPercent) {
  let discount = (price * discountPercent) / 100;
  let finalPrice = price - discount;
  return finalPrice;
}

let discountedPrice = calculateDiscount(1000, 10); 
console.log("💰 Final Price after Discount:", discountedPrice);


✅ Output:

💰 Final Price after Discount: 900

🔹 3. Returning Objects

👉 Useful for APIs or structured data.

function createUser(name, age) {
  return {
    username: name,
    userAge: age,
    isActive: true
  };
}

let user = createUser("Suraj", 25);
console.log("👤 User:", user);


✅ Output:

👤 User: { username: 'Suraj', userAge: 25, isActive: true }

🔹 4. Returning Arrays
function getTopStudents() {
  return ["Amit", "Neha", "Suraj"];
}

let students = getTopStudents();
console.log("🎓 Top Students:", students);


✅ Output:

🎓 Top Students: [ 'Amit', 'Neha', 'Suraj' ]

🔹 5. Real-Life Example: Checking Login
function checkLogin(username, password) {
  if (username === "admin" && password === "12345") {
    return "✅ Login Successful!";
  }
  return "❌ Invalid Credentials!";
}

console.log(checkLogin("admin", "12345"));
console.log(checkLogin("user", "wrongpass"));


✅ Output:

✅ Login Successful!
❌ Invalid Credentials!

🔹 6. Returning Functions (Higher-Order Function)

👉 Useful in real-world apps (callbacks, closures, functional programming).

function multiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

let double = multiplier(2);
let triple = multiplier(3);

console.log("Double of 5:", double(5));
console.log("Triple of 5:", triple(5));


✅ Output:

Double of 5: 10
Triple of 5: 15

⚡ Summary

return sends values back to where the function was called.

Functions can return → numbers, strings, objects, arrays, functions.

Useful for → calculations, API data, validation, reusable logic.

============================================================
Arrow Functions () => {}
============================================================
What are Arrow Functions?

Introduced in ES6 (2015).

A shorter syntax for writing functions.

Do not have their own this, arguments, super, or new.target.

Mostly used for callbacks, array methods, and concise functions.

🔹 1. Basic Syntax
// Normal function
function add(a, b) {
  return a + b;
}

// Arrow function
const addArrow = (a, b) => a + b;

console.log("Normal:", add(5, 10));
console.log("Arrow:", addArrow(5, 10));


✅ Output:

Normal: 15
Arrow: 15

🔹 2. With One Parameter
const greet = name => `Hello, ${name}! 👋`;

console.log(greet("Suraj"));


✅ Output:

Hello, Suraj! 👋

🔹 3. With No Parameters
const welcome = () => "🎉 Welcome to our website!";

console.log(welcome());


✅ Output:

🎉 Welcome to our website!

🔹 4. Real-Life Example: Shopping Cart (Arrow Function + Map)
let cart = [
  { item: "Book", price: 200 },
  { item: "Pen", price: 50 },
  { item: "Bag", price: 500 }
];

// Arrow function inside map()
let prices = cart.map(product => product.price);

console.log("💰 Prices:", prices);


✅ Output:

💰 Prices: [200, 50, 500]

🔹 5. Real-Life Example: Filtering Users
let users = [
  { name: "Suraj", age: 25 },
  { name: "Amit", age: 17 },
  { name: "Neha", age: 30 }
];

// Arrow function inside filter()
let adults = users.filter(user => user.age >= 18);

console.log("✅ Adults:", adults);


✅ Output:

✅ Adults: [ { name: 'Suraj', age: 25 }, { name: 'Neha', age: 30 } ]

🔹 6. Arrow Function with this (Important Difference)

👉 Normal functions create their own this, but arrow functions do not.

// Normal function
const person1 = {
  name: "Suraj",
  greet: function() {
    console.log("Hello, I'm " + this.name);
  }
};
person1.greet();

// Arrow function (doesn't bind `this`)
const person2 = {
  name: "Suraj",
  greet: () => {
    console.log("Hello, I'm " + this.name); // `this` = undefined/global
  }
};
person2.greet();


✅ Output:

Hello, I'm Suraj
Hello, I'm undefined


👉 So:

Use normal functions when you need this.

Use arrow functions for short callbacks where this isn’t needed.

🔹 7. Real-Life Example: Event Listener
// Normal function
document.getElementById("btn").addEventListener("click", function() {
  console.log("Button clicked ✅");
});

// Arrow function
document.getElementById("btn").addEventListener("click", () => {
  console.log("Button clicked with Arrow ✅");
});

⚡ Summary

Arrow Functions = Short, cleaner, best for callbacks.

Do not bind their own this → useful in avoiding bugs.

Widely used in → array methods (map, filter, reduce), event handlers, async code.

============================================================
Default Parameters
============================================================
What are Default Parameters?

Introduced in ES6 (2015).

Allow you to set default values for function parameters if no argument (or undefined) is provided.

Helps avoid bugs when values are missing.

🔹 1. Basic Example
function greet(name = "Guest") {
  console.log(`Hello, ${name}! 👋`);
}

greet("Suraj");  // Argument passed
greet();         // No argument → uses default


✅ Output:

Hello, Suraj! 👋
Hello, Guest! 👋

🔹 2. Real-Life Example: Online Shopping Delivery
function placeOrder(item, delivery = "Standard Delivery") {
  console.log(`🛒 Order placed: ${item} | 🚚 Delivery: ${delivery}`);
}

placeOrder("Laptop", "Express Delivery");
placeOrder("Book"); // uses default


✅ Output:

🛒 Order placed: Laptop | 🚚 Delivery: Express Delivery
🛒 Order placed: Book | 🚚 Delivery: Standard Delivery

🔹 3. Real-Life Example: Event Booking
function bookEvent(eventName, seats = 1) {
  console.log(`🎟️ Booking confirmed for ${eventName} with ${seats} seat(s).`);
}

bookEvent("Movie Night", 3);
bookEvent("Concert"); // default seats = 1


✅ Output:

🎟️ Booking confirmed for Movie Night with 3 seat(s).
🎟️ Booking confirmed for Concert with 1 seat(s).

🔹 4. Real-Life Example: Sending Emails
function sendEmail(to, subject = "No Subject", message = "No Message") {
  console.log(`📧 Email sent to: ${to}`);
  console.log(`   Subject: ${subject}`);
  console.log(`   Message: ${message}`);
}

sendEmail("user@gmail.com", "Welcome", "Thanks for joining us!");
sendEmail("admin@gmail.com"); // subject & message use defaults


✅ Output:

📧 Email sent to: user@gmail.com
   Subject: Welcome
   Message: Thanks for joining us!
📧 Email sent to: admin@gmail.com
   Subject: No Subject
   Message: No Message

🔹 5. Default Parameter with Expression

👉 You can even set default values based on other parameters.

function calculatePrice(price, tax = price * 0.1) {
  return price + tax;
}

console.log("Total Price:", calculatePrice(1000)); // tax = 100
console.log("Total Price:", calculatePrice(1000, 200)); // custom tax


✅ Output:

Total Price: 1100
Total Price: 1200

⚡ Summary

Default parameters prevent undefined issues.

Can be simple values, objects, or even expressions.

Widely used in e-commerce apps, booking systems, APIs, and form handling.

============================================================
Rest & Spread Operators (...)
============================================================
The ... (three dots) in JavaScript have two different roles depending on where they are used:

Rest Operator (...) → Collects multiple values into an array.

Spread Operator (...) → Spreads (expands) values from an array/object.

Let’s go step by step with real-based examples 👇

🔹 1. Rest Operator (...)

👉 Used in function parameters to gather remaining arguments into an array.

📌 Example: Shopping Cart (Unknown number of items)
function addToCart(...items) {
  console.log("🛒 Items in cart:", items);
}

addToCart("Book", "Pen", "Laptop");


✅ Output:

🛒 Items in cart: [ 'Book', 'Pen', 'Laptop' ]

📌 Example: Calculate Total Price
function calculateTotal(...prices) {
  return prices.reduce((sum, price) => sum + price, 0);
}

console.log("💰 Total:", calculateTotal(200, 150, 50, 100));


✅ Output:

💰 Total: 500

🔹 2. Spread Operator (...)

👉 Used to expand arrays/objects into individual elements.

📌 Example: Copying Arrays (Avoid mutation)
let fruits = ["Apple", "Banana", "Mango"];
let newFruits = [...fruits, "Orange"];

console.log("🍎 Fruits:", newFruits);


✅ Output:

🍎 Fruits: [ 'Apple', 'Banana', 'Mango', 'Orange' ]

📌 Example: Merging Arrays
let electronics = ["Laptop", "Phone"];
let accessories = ["Charger", "Headphones"];

let storeItems = [...electronics, ...accessories];
console.log("🏬 Store Items:", storeItems);


✅ Output:

🏬 Store Items: [ 'Laptop', 'Phone', 'Charger', 'Headphones' ]

📌 Example: Copying & Updating Objects
let user = { name: "Suraj", age: 25 };
let updatedUser = { ...user, country: "India" };

console.log("👤 User:", updatedUser);


✅ Output:

👤 User: { name: 'Suraj', age: 25, country: 'India' }

📌 Example: Passing Array as Function Arguments
function sum(a, b, c) {
  return a + b + c;
}

let numbers = [10, 20, 30];
console.log("➕ Sum:", sum(...numbers));


✅ Output:

➕ Sum: 60

🔹 3. Real-Life Examples
✅ Rest: Event Attendance System
function registerEvent(eventName, ...participants) {
  console.log(`🎉 Event: ${eventName}`);
  console.log("👥 Participants:", participants);
}

registerEvent("Hackathon", "Suraj", "Neha", "Amit");


✅ Output:

🎉 Event: Hackathon
👥 Participants: [ 'Suraj', 'Neha', 'Amit' ]

✅ Spread: API Response Merge
let apiResponse1 = { id: 1, name: "Suraj" };
let apiResponse2 = { age: 25, country: "India" };

let userProfile = { ...apiResponse1, ...apiResponse2 };
console.log("📡 User Profile:", userProfile);


✅ Output:

📡 User Profile: { id: 1, name: 'Suraj', age: 25, country: 'India' }

⚡ Summary
Operator	Meaning	Use Case
Rest (...)	Collects arguments into an array	Unknown number of function arguments
Spread (...)	Expands arrays/objects	Copy, merge, pass elements

============================================================
Callback Functions
============================================================
What is a Callback Function?

A callback function is a function passed as an argument to another function and executed later, usually after some task is completed.

👉 They are heavily used in asynchronous JavaScript (e.g., API calls, timers, events).

🔹 1. Basic Example of Callback
function greetUser(name, callback) {
  console.log("Hello, " + name);
  callback(); // calling the callback function
}

function sayGoodbye() {
  console.log("Goodbye! 👋");
}

greetUser("Suraj", sayGoodbye);


✅ Output:

Hello, Suraj
Goodbye! 👋

🔹 2. Callback with Anonymous Function
function processNumber(num, callback) {
  let result = num * 2;
  callback(result);
}

processNumber(5, function(output) {
  console.log("Doubled Number:", output);
});


✅ Output:

Doubled Number: 10

🔹 3. Real-Life Examples of Callback Functions
📌 Example 1: Using setTimeout (Simulating async task like order confirmation)
function placeOrder(order, callback) {
  console.log(`📦 Placing order for: ${order}...`);
  
  setTimeout(() => {
    console.log(`✅ Order ready: ${order}`);
    callback();
  }, 2000);
}

placeOrder("Pizza", function() {
  console.log("🚚 Delivered to your address!");
});


✅ Output:

📦 Placing order for: Pizza...
✅ Order ready: Pizza
🚚 Delivered to your address!

📌 Example 2: Reading File (Simulation)
function readFile(fileName, callback) {
  console.log(`📂 Reading file: ${fileName}...`);

  setTimeout(() => {
    callback(`File content of ${fileName}`);
  }, 1500);
}

readFile("notes.txt", function(content) {
  console.log("📑 File Data:", content);
});


✅ Output:

📂 Reading file: notes.txt...
📑 File Data: File content of notes.txt

📌 Example 3: Event Listener (Button Click)
<button id="clickBtn">Click Me</button>

<script>
document.getElementById("clickBtn").addEventListener("click", function() {
  console.log("👆 Button was clicked!");
});
</script>


✅ Output when button is clicked:

👆 Button was clicked!

🔹 4. Callback in Array Methods

👉 Functions like map, filter, forEach use callbacks.

let numbers = [1, 2, 3, 4, 5];

let doubled = numbers.map(function(num) {
  return num * 2;
});

console.log("🔢 Doubled:", doubled);


✅ Output:

🔢 Doubled: [ 2, 4, 6, 8, 10 ]

⚡ Summary

A callback function is passed as an argument to another function.

Used in async programming (API calls, setTimeout, events).

Real-life use cases: order system, file reading, button clicks, array operations.

============================================================
Higher-Order Functions
============================================================
What is a Higher-Order Function?

A Higher-Order Function (HOF) is a function that either:

Takes another function as an argument (callback), OR

Returns a function.

👉 In JavaScript, functions are first-class citizens, meaning they can be passed around like variables.

🔹 1. HOF Taking a Function as Argument
📌 Example: Payment System
function makePayment(amount, onSuccess, onFailure) {
  if (amount > 0) {
    onSuccess(amount); // calling callback
  } else {
    onFailure("Invalid payment amount");
  }
}

makePayment(
  500,
  (amt) => console.log(`✅ Payment of ₹${amt} successful!`),
  (error) => console.log(`❌ Payment failed: ${error}`)
);


✅ Output:

✅ Payment of ₹500 successful!

🔹 2. HOF Returning Another Function
📌 Example: Discount Generator
function discountCalculator(discount) {
  return function(price) {
    return price - (price * discount);
  };
}

let studentDiscount = discountCalculator(0.2); // 20% discount
console.log("🎓 Student Price:", studentDiscount(1000));

let festivalDiscount = discountCalculator(0.5); // 50% discount
console.log("🎉 Festival Price:", festivalDiscount(1000));


✅ Output:

🎓 Student Price: 800
🎉 Festival Price: 500

🔹 3. Real-Based Examples Using Built-in HOFs
✅ Example 1: Online Store – map
let products = [100, 200, 300];
let gstPrices = products.map(price => price + price * 0.18);

console.log("🛍️ Prices with GST:", gstPrices);


✅ Output:

🛍️ Prices with GST: [ 118, 236, 354 ]

✅ Example 2: Filtering Students – filter
let students = [
  { name: "Suraj", marks: 85 },
  { name: "Neha", marks: 45 },
  { name: "Amit", marks: 70 }
];

let passed = students.filter(student => student.marks >= 50);
console.log("🎓 Passed Students:", passed);


✅ Output:

🎓 Passed Students: [ { name: 'Suraj', marks: 85 }, { name: 'Amit', marks: 70 } ]

✅ Example 3: Shopping Cart Total – reduce
let cart = [200, 150, 50];

let total = cart.reduce((sum, price) => sum + price, 0);
console.log("💰 Cart Total:", total);


✅ Output:

💰 Cart Total: 400

✅ Example 4: Event Management – forEach
let attendees = ["Suraj", "Neha", "Amit"];

attendees.forEach(person => console.log(`🎉 Welcome, ${person}!`));


✅ Output:

🎉 Welcome, Suraj!
🎉 Welcome, Neha!
🎉 Welcome, Amit!

🔹 4. HOF in Real-World Automation
📌 Example: Email Notification System
function sendNotification(users, callback) {
  users.forEach(user => {
    callback(user);
  });
}

let users = ["suraj@example.com", "neha@example.com"];

sendNotification(users, (email) => {
  console.log(`📧 Email sent to ${email}`);
});


✅ Output:

📧 Email sent to suraj@example.com
📧 Email sent to neha@example.com

⚡ Summary
Concept	Example
Takes a function as argument	map, filter, reduce, custom callback systems
Returns a function	Discount calculator, configuration functions
Real-life use	Payments, shopping carts, student filtering, notifications

===========================================================
🟠 4. Core Concepts
===========================================================

===========================================================
Scope (Block, Function, Global)
===========================================================
What is Scope?

Scope defines where a variable can be accessed in your code.
In JavaScript, we mainly have:

Block Scope

Function Scope

Global Scope

🔹 1. Global Scope 🌍

👉 A variable declared outside any function or block is global.
👉 Accessible from anywhere in the program.

📌 Example: Website Theme
let theme = "🌙 Dark Mode"; // Global Scope

function showTheme() {
  console.log("Current Theme:", theme);
}

showTheme();
console.log("Applied Theme Everywhere:", theme);


✅ Output:

Current Theme: 🌙 Dark Mode
Applied Theme Everywhere: 🌙 Dark Mode


💡 Real-life: A global theme applies to all pages of a website.

🔹 2. Function Scope 🔧

👉 Variables declared with var, let, or const inside a function are only available within that function.

📌 Example: Online Banking – Balance
function checkBalance() {
  let balance = 5000; // Function Scope
  console.log("💰 Inside function - Balance:", balance);
}

checkBalance();
// console.log(balance); // ❌ Error: balance is not defined


✅ Output:

💰 Inside function - Balance: 5000


💡 Real-life: Your bank balance is private inside your account, not visible outside.

🔹 3. Block Scope 📦

👉 Variables declared with let or const inside a block {} are only accessible within that block.
👉 var ignores block scope (it leaks out).

📌 Example: Discount Offer
if (true) {
  let discount = "🎉 20% OFF";  // Block Scope
  console.log("Available Offer:", discount);
}

// console.log(discount); // ❌ Error: discount is not defined


✅ Output:

Available Offer: 🎉 20% OFF


💡 Real-life: Discounts are limited to a festival period (block), not available globally.

🔹 4. Comparing var, let, and const in Scope
if (true) {
  var city = "Pune";     // function or global scope
  let state = "Maharashtra"; // block scope
  const country = "India";   // block scope
}

console.log(city);    // ✅ Works
// console.log(state);  // ❌ Error
// console.log(country);// ❌ Error


✅ Output:

Pune


💡 var leaks out of blocks, while let and const stay inside.

🔹 5. Nested Scope (Scope Chain)

👉 Inner functions can access variables from outer functions (but not vice versa).

📌 Example: Restaurant Order
let restaurant = "🍴 Food Hub";

function placeOrder() {
  let order = "Pizza";

  function kitchen() {
    let chef = "👨‍🍳 Chef Ramesh";
    console.log(`${chef} is preparing ${order} at ${restaurant}`);
  }

  kitchen();
}

placeOrder();


✅ Output:

👨‍🍳 Chef Ramesh is preparing Pizza at 🍴 Food Hub


💡 Real-life: The kitchen (inner scope) knows the restaurant and order, but the restaurant cannot see the chef’s private details.

⚡ Summary Table
Scope Type	Keyword	Access
Global	var, let, const (outside functions)	Accessible everywhere
Function	var, let, const (inside function)	Only inside that function
Block	let, const	Only inside {} block
Scope Chain	Nested scopes	Inner can access outer variables

===========================================================
Hoisting
===========================================================
What is Hoisting?

Hoisting is JavaScript’s default behavior of moving variable and function declarations to the top of their scope before code execution.

👉 In simple words:
You can use functions or variables before they are declared (but with different behaviors depending on var, let, const).

🔹 1. Hoisting with var

var declarations are hoisted but initialized as undefined.

📌 Example: Shopping Cart Quantity
console.log("🛒 Items in cart:", items); // undefined
var items = 5;
console.log("🛒 Items after update:", items);


✅ Output:

🛒 Items in cart: undefined
🛒 Items after update: 5


💡 Real-life: Like keeping a placeholder basket in a shopping cart — it exists, but it’s empty (undefined) until you add items.

🔹 2. Hoisting with let and const

let and const are hoisted but not initialized.

They stay in the Temporal Dead Zone (TDZ) until the actual declaration.

📌 Example: Festival Discount
// console.log(discount); // ❌ ReferenceError
let discount = "🎉 20% OFF";
console.log("Festival Discount:", discount);


✅ Output:

Festival Discount: 🎉 20% OFF


💡 Real-life: The discount exists in system memory but you can’t use it until the festival actually starts.

🔹 3. Function Hoisting

👉 Function declarations are hoisted completely.
👉 Function expressions/arrow functions behave like variables (var, let, const).

📌 Example: ATM Withdrawal
withdraw(2000); // ✅ Works because function is hoisted

function withdraw(amount) {
  console.log(`💰 Withdrawn: ₹${amount}`);
}


✅ Output:

💰 Withdrawn: ₹2000

📌 Example: Function Expression (Not Hoisted Properly)
// withdraw(2000); // ❌ Error: Cannot access 'withdraw' before initialization

const withdraw = function(amount) {
  console.log(`💰 Withdrawn: ₹${amount}`);
};


💡 Real-life:

Function Declaration = ATM machine is always ready.

Function Expression = ATM machine isn’t set up until staff configures it.

🔹 4. Real-Based Example: Restaurant Menu
console.log("Today's Special:", menu); // undefined

var menu = "🍕 Pizza";
console.log("Updated Menu:", menu);

// console.log(drink); // ❌ ReferenceError
let drink = "🥤 Coke";
console.log("Drink of the Day:", drink);


✅ Output:

Today's Special: undefined
Updated Menu: 🍕 Pizza
Drink of the Day: 🥤 Coke


💡 Real-life:

Menu (var) exists but blank (undefined) until chef writes it.

Drink (let) can’t even be seen until the staff puts it up.

⚡ Summary Table
Keyword	Hoisted?	Initialized?	Access before declaration
var	✅ Yes	undefined	Allowed, gives undefined
let	✅ Yes	❌ No	❌ ReferenceError
const	✅ Yes	❌ No	❌ ReferenceError
function	✅ Yes	✅ Yes	Allowed, fully usable
function expression	Like variable	Depends on var/let/const	Error or undefined

===========================================================
Closures
===========================================================
.

🔹 What is a Closure?

A closure is created when a function remembers and accesses variables from its outer scope even after that outer function has finished executing.

👉 In simple words:

"A closure gives you access to an outer function’s variables from an inner function, even after the outer function has closed."

🔹 1. Basic Closure Example
function outer() {
  let message = "Hello from Closure 👋";

  function inner() {
    console.log(message); // inner has access to outer's variable
  }

  return inner;
}

const greet = outer();
greet(); // calling inner even after outer is done


✅ Output:

Hello from Closure 👋


💡 Even though outer() finished, inner() still remembers message.

🔹 2. Real-Life Examples of Closures
📌 Example 1: Bank Account (Private Balance)
function createBankAccount(initialBalance) {
  let balance = initialBalance; // private variable

  return {
    deposit: function(amount) {
      balance += amount;
      console.log(`💰 Deposited: ₹${amount}, New Balance: ₹${balance}`);
    },
    withdraw: function(amount) {
      if (amount <= balance) {
        balance -= amount;
        console.log(`🏧 Withdrawn: ₹${amount}, Remaining Balance: ₹${balance}`);
      } else {
        console.log("❌ Insufficient funds!");
      }
    },
    checkBalance: function() {
      console.log(`📊 Current Balance: ₹${balance}`);
    }
  };
}

const myAccount = createBankAccount(1000);
myAccount.deposit(500);
myAccount.withdraw(300);
myAccount.checkBalance();


✅ Output:

💰 Deposited: ₹500, New Balance: ₹1500
🏧 Withdrawn: ₹300, Remaining Balance: ₹1200
📊 Current Balance: ₹1200


💡 Here, balance is private. It’s not directly accessible from outside, only through closure functions.

📌 Example 2: Restaurant Order Counter
function orderCounter() {
  let count = 0; // private variable

  return function() {
    count++;
    console.log(`🍽️ Orders placed: ${count}`);
  };
}

const takeOrder = orderCounter();

takeOrder(); // 🍽️ Orders placed: 1
takeOrder(); // 🍽️ Orders placed: 2
takeOrder(); // 🍽️ Orders placed: 3


💡 Closure keeps track of how many orders are placed even after orderCounter() has finished.

📌 Example 3: Event Booking System
function createEvent(eventName) {
  let attendees = [];

  return {
    register: function(name) {
      attendees.push(name);
      console.log(`🎟️ ${name} registered for ${eventName}`);
    },
    listAttendees: function() {
      console.log(`👥 Attendees for ${eventName}: ${attendees.join(", ")}`);
    }
  };
}

const hackathon = createEvent("Hackathon 2025");
hackathon.register("Suraj");
hackathon.register("Neha");
hackathon.listAttendees();


✅ Output:

🎟️ Suraj registered for Hackathon 2025
🎟️ Neha registered for Hackathon 2025
👥 Attendees for Hackathon 2025: Suraj, Neha


💡 Closure keeps track of attendees specific to each event.

🔹 3. Why Are Closures Useful?

✅ Data privacy (like private variables)
✅ Maintaining state (like counters, balance, attendees)
✅ Used in callbacks, event handlers, and async code
✅ Popular in module patterns

⚡ Summary

A closure allows an inner function to access outer function’s variables even after the outer function finishes.

Real-life use: Bank accounts, order counters, booking systems, event management, private data.

===========================================================
The this keyword
===========================================================
What is this?

The this keyword refers to the object that is currently executing the function.
Its value depends on how (and where) a function is called.

🔹 1. Global Context 🌍

In the global scope:

In browser, this → window object.

In Node.js, this → {} (empty object in modules).

📌 Example: Website Environment
console.log(this); // In browser → window


💡 Real-life: Think of window as the entire website environment, and this points to it globally.

🔹 2. Inside an Object (Method Call)

When a function is called as an object’s method, this refers to that object.

📌 Example: Online Store Product
let product = {
  name: "Laptop",
  price: 50000,
  showDetails: function() {
    console.log(`💻 ${this.name} costs ₹${this.price}`);
  }
};

product.showDetails();


✅ Output:

💻 Laptop costs ₹50000


💡 Real-life: this points to the product object, so it knows its own name and price.

🔹 3. In a Regular Function (Not Method)

If a function is called normally (not as object method):

In strict mode, this = undefined.

In non-strict mode, this = global object (window).

📌 Example: Random Utility Function
function show() {
  console.log(this);
}
show(); // window (in browser), undefined (in strict mode)

🔹 4. With this in Constructor Functions / Classes

When used inside a constructor function or class, this refers to the newly created object.

📌 Example: User Account System
function User(name, balance) {
  this.name = name;
  this.balance = balance;
}

let user1 = new User("Suraj", 1000);
console.log(`👤 ${user1.name}, Balance: ₹${user1.balance}`);


✅ Output:

👤 Suraj, Balance: ₹1000


💡 Real-life: Each new user gets their own data, and this points to that user object.

🔹 5. Arrow Functions & this

👉 Arrow functions do not have their own this.
👉 They inherit this from their surrounding scope (lexical scope).

📌 Example: Event Listener
let button = {
  label: "Submit",
  click: function() {
    setTimeout(() => {
      console.log(`🔘 Button clicked: ${this.label}`);
    }, 1000);
  }
};

button.click();


✅ Output:

🔘 Button clicked: Submit


💡 Here, arrow function keeps this from click method (the button object).

🔹 6. this in Event Listeners

👉 In regular functions, this = the element that triggered the event.

📌 Example: Form Submit Button
<button id="submitBtn">Submit</button>

<script>
document.getElementById("submitBtn").addEventListener("click", function() {
  console.log("Clicked:", this.innerText); // "Submit"
});
</script>


✅ Output (on click):

Clicked: Submit


💡 Real-life: this points to the button element itself.

🔹 7. call, apply, bind with this

👉 We can manually control what this points to.

📌 Example: Borrowing Methods
let customer = { name: "Suraj" };
let bank = {
  name: "SBI",
  welcome: function() {
    console.log(`🏦 Welcome ${this.name} to our bank`);
  }
};

bank.welcome.call(customer);


✅ Output:

🏦 Welcome Suraj to our bank


💡 Real-life: Like borrowing SBI’s welcome message and applying it for Suraj.

⚡ Summary Table
Context	this Refers To
Global (browser)	window
Object Method	The object
Function (strict)	undefined
Function (non-strict)	window
Constructor / Class	New object
Arrow Function	Inherits from parent scope
Event Listener	The element
call / apply / bind	Explicitly set object

===========================================================
Execution Context & Call Stack
===========================================================
1. What is Execution Context?

An Execution Context (EC) is the environment in which JavaScript code is evaluated and executed.

There are 3 main types:

Global Execution Context (GEC) – Created when JS first runs (default).

Function Execution Context (FEC) – Created every time a function is called.

Eval Execution Context (less common, using eval()).

👉 Each context has:

Variable Environment (Memory/Hoisting phase)

Scope Chain

this binding

🔹 2. What is Call Stack?

The Call Stack is a stack data structure that keeps track of execution contexts.

When a function is invoked → A new FEC is pushed onto the stack.

When the function finishes → It is popped off the stack.

🔹 3. Example: Online Shopping Flow 🛒
function browseProducts() {
  console.log("🛍️ Browsing products...");
}

function addToCart() {
  console.log("🛒 Adding product to cart...");
  payment(); // call another function
}

function payment() {
  console.log("💳 Processing payment...");
}

function shopping() {
  browseProducts();
  addToCart();
}

shopping();

🔹 Step-by-Step Execution (Call Stack)

Global Execution Context (GEC) created → shopping() is defined.

shopping() is called → Push shopping() FEC onto stack.

Inside shopping() → Calls browseProducts() → Push browseProducts() FEC.

browseProducts() executes → Logs message → Pop it off.

Back to shopping(), calls addToCart() → Push addToCart() FEC.

Inside addToCart() → Calls payment() → Push payment() FEC.

payment() executes → Pop off after completion.

addToCart() finishes → Pop off.

shopping() finishes → Pop off.

Only GEC remains.

✅ Output:
🛍️ Browsing products...
🛒 Adding product to cart...
💳 Processing payment...

🔹 4. Real-Life Analogy

Think of Call Stack like a restaurant kitchen order system 🍽️:

Each Execution Context = one order.

Call Stack = pile of orders (stack of plates).

Chef (JS engine) handles last order first (LIFO).

When one dish is completed (function finishes), the plate (FEC) is removed.

🔹 5. Example with setTimeout (Async) ⏳

JavaScript is single-threaded, but async code is handled by Web APIs + Callback Queue (not on Call Stack directly).

console.log("🍽️ Order placed");

setTimeout(() => {
  console.log("🍲 Food served after 2 sec");
}, 2000);

console.log("💬 Chatting with friends");

✅ Output:
🍽️ Order placed
💬 Chatting with friends
🍲 Food served after 2 sec


💡 Real-life: You order food (setTimeout), meanwhile you chat (other tasks). When food is ready (callback), waiter brings it after the delay.

⚡ Summary
Concept	Meaning	Real-Life Example
Execution Context	Environment where code runs	Kitchen preparing a dish
Global Execution Context	Default when script runs	Restaurant setup
Function Execution Context	Created when function runs	Each new food order
Call Stack	Tracks order of execution	Stack of plates with orders
Pop/Push	Add/remove from stack	Chef starts/finishes a dish

===========================================================
Lexical Environment
===========================================================
1. What is Lexical Environment?

A Lexical Environment in JavaScript is the place where variables and functions are physically declared in the code.

👉 In simple terms:

Lexical = related to “position in code” (where written)

Every Execution Context has a Lexical Environment.

A Lexical Environment has two parts:

Environment Record → Stores variables & function declarations.

Reference to outer environment → For scope chain (if variable not found locally).

🔹 2. Simple Example
function outer() {
  let shopName = "SuperMart 🏬";

  function inner() {
    console.log("Shopping at", shopName);
  }

  inner();
}

outer();


✅ Output:

Shopping at SuperMart 🏬


👉 Here:

inner() has no variable shopName.

It looks into its Lexical Environment → outer() → found shopName.

This is possible because inner is defined inside outer (lexical position).

🔹 3. Real-Life Example: Bank 🏦
function bank() {
  let bankName = "HDFC Bank 🏦";

  function account(customer) {
    console.log(`${customer} has an account in ${bankName}`);
  }

  account("Suraj");
  account("Neha");
}

bank();


✅ Output:

Suraj has an account in HDFC Bank 🏦
Neha has an account in HDFC Bank 🏦


👉 Here:

Function account() doesn’t have bankName.

It uses outer lexical environment (bank) to access it.

🔹 4. Nested Lexical Environments (Scope Chain)
let country = "India 🇮🇳";

function state() {
  let stateName = "Maharashtra";

  function city() {
    let cityName = "Pune";
    console.log(`${cityName}, ${stateName}, ${country}`);
  }

  city();
}

state();


✅ Output:

Pune, Maharashtra, India 🇮🇳


👉 Execution flow:

cityName → found in city()

stateName → not in city(), found in state() lexical environment

country → not in state(), found in global lexical environment

That’s the scope chain powered by lexical environments.

🔹 5. Real-Life Analogy 📖

Think of a Lexical Environment like a filing cabinet system:

If you can’t find a file (variable) in your own drawer (local scope),

You check the next outer drawer (parent scope),

Keep going until you find it (global scope).

⚡ Summary
Concept	Meaning	Real-Life Example
Lexical Environment	Where variable/function is declared (position in code)	Filing cabinet with drawers
Environment Record	Stores variables and function declarations	Documents in current drawer
Outer Reference	Link to parent lexical scope	Key to parent drawer
Scope Chain	Chain of lexical environments	Searching multiple drawers

===========================================================
Strict Mode ("use strict")
===========================================================
1. What is Strict Mode?

"use strict" was introduced in ECMAScript 5 (ES5).

It enforces stricter parsing and error handling in JavaScript.

Helps developers write cleaner, more secure, and less error-prone code.

👉 To enable it:

"use strict";   // at top of file (applies globally)
// or inside a function (applies locally)

🔹 2. Why Use Strict Mode?

✅ Prevents accidental errors
✅ Avoids using undeclared variables
✅ Makes debugging easier
✅ Reserved keywords (like public, static) cannot be used as variable names

🔹 3. Examples
📌 Example 1: Using Undeclared Variables ❌
// Without strict mode
name = "Suraj"; 
console.log(name); // Works, but creates global variable accidentally

// With strict mode
"use strict";
name = "Suraj";  // ❌ Error: name is not defined


👉 Real-life analogy: Imagine accidentally writing customer data in the wrong file — strict mode forces you to declare properly before use.

📌 Example 2: Prevents Duplicate Parameters 🚫
// Without strict mode
function sum(a, a, b) {
  return a + b; // Works, but confusing
}
console.log(sum(1, 2, 3)); // 5

// With strict mode
"use strict";
function sum(a, a, b) {   // ❌ SyntaxError
  return a + b;
}


👉 Real-life analogy: Like giving two students the same roll number — strict mode avoids confusion.

📌 Example 3: Prevents Writing to Read-Only Properties 🔒
"use strict";
const obj = {};
Object.defineProperty(obj, "id", { value: 101, writable: false });

obj.id = 202;  // ❌ TypeError: Cannot assign to read only property


👉 Real-life analogy: Think of trying to edit your Aadhaar number — system doesn’t allow modification.

📌 Example 4: Disallows Reserved Keywords 🚫
"use strict";
let public = "data";  // ❌ SyntaxError
let static = 123;     // ❌ SyntaxError


👉 Prevents future conflicts since these may be reserved in newer versions of JS.

📌 Example 5: In Functions (Local Strict Mode)
function normalFunc() {
  x = 10;  // Works (becomes global accidentally)
  console.log("Normal:", x);
}

function strictFunc() {
  "use strict";
  y = 20;  // ❌ Error: y is not defined
}

normalFunc();
strictFunc();


👉 Real-life analogy: Think of strict exam hall rules (inside function) vs. casual class rules (normal function).

⚡ Summary
Without Strict Mode	With Strict Mode
Allows undeclared variables	❌ Error if undeclared
Duplicate function params	❌ Not allowed
Silent failures (no error)	❌ Throws error
Reserved keywords allowed	❌ Not allowed
Global pollution risk	✅ Safer code

=============================================================
5. Objects & Arrays
=============================================================
🔹 1. Objects in JavaScript

👉 An object is a collection of key–value pairs (like a dictionary).
It represents a real-world entity with properties (data) and methods (functions).

📌 Real-Life Example: Customer Profile 👤
let customer = {
  name: "Suraj Pawar",
  age: 28,
  email: "suraj@example.com",
  address: {
    city: "Pune",
    country: "India"
  },
  orders: ["Laptop", "Phone", "Headphones"],

  // method
  greet: function() {
    console.log(`Hello, ${this.name}! Welcome back to our store.`);
  }
};

console.log(customer.name);       // Suraj Pawar
console.log(customer.address.city); // Pune
console.log(customer.orders[1]);  // Phone
customer.greet();                 // Hello, Suraj! Welcome back to our store.


✅ Output:

Suraj Pawar
Pune
Phone
Hello, Suraj! Welcome back to our store.


👉 Real-life analogy: An object is like a customer profile in a shop’s database.

🔹 2. Arrays in JavaScript

👉 An array is an ordered collection of values (can store multiple items in one variable).

📌 Real-Life Example: Shopping Cart 🛒
let cart = ["Shirt", "Jeans", "Shoes", "Watch"];

console.log("🛒 Items in cart:", cart);
console.log("First Item:", cart[0]);  // Shirt
console.log("Total Items:", cart.length); // 4

// Adding new item
cart.push("Cap");
console.log("Updated Cart:", cart);

// Removing last item
cart.pop();
console.log("After Removing:", cart);

// Iterating over cart
cart.forEach((item, index) => {
  console.log(`${index + 1}. ${item}`);
});


✅ Output:

🛒 Items in cart: [ 'Shirt', 'Jeans', 'Shoes', 'Watch' ]
First Item: Shirt
Total Items: 4
Updated Cart: [ 'Shirt', 'Jeans', 'Shoes', 'Watch', 'Cap' ]
After Removing: [ 'Shirt', 'Jeans', 'Shoes', 'Watch' ]
1. Shirt
2. Jeans
3. Shoes
4. Watch


👉 Real-life analogy: An array is like a shopping cart holding multiple products.

🔹 3. Objects + Arrays Together
📌 Real-Life Example: E-commerce Order System 🛍️
let orders = [
  {
    orderId: 101,
    customer: "Suraj",
    items: ["Laptop", "Mouse"],
    total: 55000
  },
  {
    orderId: 102,
    customer: "Neha",
    items: ["Phone", "Earbuds"],
    total: 32000
  }
];

// Accessing data
console.log("First Order by:", orders[0].customer);  
console.log("Neha bought:", orders[1].items[0]);  

// Loop through orders
orders.forEach(order => {
  console.log(`Order ${order.orderId} - ${order.customer} - Total: ₹${order.total}`);
});


✅ Output:

First Order by: Suraj
Neha bought: Phone
Order 101 - Suraj - Total: ₹55000
Order 102 - Neha - Total: ₹32000


👉 Real-life analogy: An array of objects is like a list of all customer orders in a database.

⚡ Summary
Concept	Real-Life Example
Object	Customer profile (name, age, email, address, orders)
Array	Shopping cart (list of items)
Array of Objects	List of all orders in an e-commerce app

✅ Objects represent entities (with details).
✅ Arrays represent collections (lists of items).
✅ Together, they power real-world apps like e-commerce, banking, ticket booking.

=============================================================
Creating Objects ({} and new Object())
=============================================================
🔹 1. Creating Object using Object Literal {}

👉 The most common and simple way to create objects.

📌 Example: Employee Profile 🏢
let employee = {
  id: 101,
  name: "Suraj Pawar",
  role: "Software Developer",
  skills: ["JavaScript", "React", "Node.js"],

  work: function() {
    console.log(`${this.name} is working as ${this.role}`);
  }
};

console.log(employee.name);   // Suraj Pawar
employee.work();              // Suraj Pawar is working as Software Developer


✅ Output:

Suraj Pawar
Suraj Pawar is working as Software Developer


👉 Real-life analogy: Think of this as quickly filling out an employee form with details.

🔹 2. Creating Object using new Object()

👉 Another way is using the Object constructor.
You create an empty object and then add properties.

📌 Example: Bank Account 🏦
let bankAccount = new Object();

bankAccount.accountNumber = "1234567890";
bankAccount.holderName = "Neha Sharma";
bankAccount.balance = 50000;
bankAccount.deposit = function(amount) {
  this.balance += amount;
  console.log(`Deposited ₹${amount}. New Balance: ₹${this.balance}`);
};

console.log(bankAccount.holderName);  // Neha Sharma
bankAccount.deposit(10000);


✅ Output:

Neha Sharma
Deposited ₹10000. New Balance: ₹60000


👉 Real-life analogy: Like opening a new blank account in a bank and then filling in details step by step.

🔹 3. Comparing {} vs new Object()
Feature	{}	new Object()
Syntax	Short & clean	Longer & explicit
Usage	Most commonly used	Rare, but useful when adding properties dynamically
Example	let obj = { name: "Suraj" }	let obj = new Object(); obj.name = "Suraj";
🔹 4. Real-Life Example: Online Store 🛍️
Using Object Literal {}
let product = {
  id: 201,
  name: "Laptop",
  price: 55000,
  inStock: true
};

console.log(product);

Using new Object()
let order = new Object();
order.orderId = 501;
order.customer = "Suraj";
order.items = ["Laptop", "Mouse"];
order.total = 56000;

console.log(order);


✅ Output:

{ id: 201, name: 'Laptop', price: 55000, inStock: true }
{ orderId: 501, customer: 'Suraj', items: [ 'Laptop', 'Mouse' ], total: 56000 }

⚡ Summary

{} → Best for quick object creation.

new Object() → Useful when you want to create an empty object and add properties later.

Both represent real-world entities (employees, bank accounts, products, orders).

=============================================================
Object Methods (Object.keys, Object.values, Object.entries)
=============================================================
🔹 1. Object.keys(obj)

👉 Returns an array of all property names (keys) in an object.

📌 Real-Life Example: Product Info 🛍️
let product = {
  id: 101,
  name: "Laptop",
  brand: "Dell",
  price: 55000
};

let keys = Object.keys(product);
console.log("Product Keys:", keys);


✅ Output:

Product Keys: [ 'id', 'name', 'brand', 'price' ]


👉 Use Case: To list all available details about a product.

🔹 2. Object.values(obj)

👉 Returns an array of all values in an object.

📌 Real-Life Example: Customer Profile 👤
let customer = {
  name: "Suraj Pawar",
  email: "suraj@example.com",
  city: "Pune"
};

let values = Object.values(customer);
console.log("Customer Values:", values);


✅ Output:

Customer Values: [ 'Suraj Pawar', 'suraj@example.com', 'Pune' ]


👉 Use Case: To export customer data for reports.

🔹 3. Object.entries(obj)

👉 Returns an array of [key, value] pairs.

📌 Real-Life Example: Bank Account 🏦
let bankAccount = {
  accountNumber: "1234567890",
  holder: "Neha Sharma",
  balance: 60000
};

let entries = Object.entries(bankAccount);
console.log("Bank Account Entries:", entries);

// Looping through entries
entries.forEach(([key, value]) => {
  console.log(`${key}: ${value}`);
});


✅ Output:

Bank Account Entries: [
  [ 'accountNumber', '1234567890' ],
  [ 'holder', 'Neha Sharma' ],
  [ 'balance', 60000 ]
]
accountNumber: 1234567890
holder: Neha Sharma
balance: 60000


👉 Use Case: Useful when you want to display key-value pairs (like account statements).

🔹 4. Combining All Methods
📌 Real-Life Example: Online Order System 🛒
let order = {
  orderId: 501,
  customer: "Suraj",
  items: ["Laptop", "Mouse"],
  total: 56000
};

console.log("🔑 Keys:", Object.keys(order));
console.log("📦 Values:", Object.values(order));
console.log("📋 Entries:", Object.entries(order));


✅ Output:

🔑 Keys: [ 'orderId', 'customer', 'items', 'total' ]
📦 Values: [ 501, 'Suraj', [ 'Laptop', 'Mouse' ], 56000 ]
📋 Entries: [
  [ 'orderId', 501 ],
  [ 'customer', 'Suraj' ],
  [ 'items', [ 'Laptop', 'Mouse' ] ],
  [ 'total', 56000 ]
]

⚡ Summary
Method	Returns	Real-Life Use Case
Object.keys()	Array of property names	List fields in product database
Object.values()	Array of property values	Export customer details
Object.entries()	Array of [key, value] pairs	Display bank account / order summary

=============================================================
Object Destructuring
=============================================================
🔹 1. What is Object Destructuring?

👉 Object Destructuring is a shorthand way to unpack properties from an object into variables.

Instead of this:

let person = { name: "Suraj", city: "Pune" };
let name = person.name;
let city = person.city;


We can do this 👇

let { name, city } = person;
console.log(name, city); // Suraj Pune

🔹 2. Real-Life Examples
📌 Example 1: Customer Profile 👤
let customer = {
  id: 101,
  name: "Suraj Pawar",
  email: "suraj@example.com",
  city: "Pune"
};

// Destructuring
let { name, email, city } = customer;
console.log(`Customer: ${name}, Email: ${email}, City: ${city}`);


✅ Output:

Customer: Suraj Pawar, Email: suraj@example.com, City: Pune


👉 Use case: Quickly access customer details for displaying in UI.

📌 Example 2: E-Commerce Order 🛒
let order = {
  orderId: 501,
  product: "Laptop",
  price: 55000,
  status: "Shipped"
};

// Destructuring with different variable names
let { orderId, product: item, price, status } = order;

console.log(`Order#${orderId}: ${item} - ₹${price} (${status})`);


✅ Output:

Order#501: Laptop - ₹55000 (Shipped)


👉 Use case: Useful when fetching order details from API response.

📌 Example 3: Nested Object Destructuring 🏦
let bankAccount = {
  accountNumber: "1234567890",
  holder: {
    name: "Neha Sharma",
    city: "Mumbai"
  },
  balance: 75000
};

// Nested destructuring
let { holder: { name, city }, balance } = bankAccount;

console.log(`${name} from ${city} has ₹${balance} in account.`);


✅ Output:

Neha Sharma from Mumbai has ₹75000 in account.


👉 Use case: When accessing nested JSON data (like API response from banking systems).

📌 Example 4: Function Parameters (Clean API) 🌍
function displayUser({ username, age, country }) {
  console.log(`${username} is ${age} years old from ${country}`);
}

let user = { username: "Amit", age: 30, country: "India" };
displayUser(user);


✅ Output:

Amit is 30 years old from India


👉 Use case: Clean function parameters instead of writing user.username, user.age, etc.

📌 Example 5: Default Values ⚡
let product = {
  name: "Mobile",
  price: 20000
};

// stock is missing → default used
let { name, price, stock = 50 } = product;

console.log(`${name} costs ₹${price}. Available stock: ${stock}`);


✅ Output:

Mobile costs ₹20000. Available stock: 50


👉 Use case: Ensures API or DB missing fields still have safe defaults.

⚡ Summary
Feature	Example	Real-Life Use
Basic Destructuring	{ name, city } = customer	Quick access to customer details
Rename	{ product: item } = order	Avoid variable conflicts
Nested	{ holder: { name, city } } = bankAccount	Extract from complex JSON
Function Params	function({ username, age })	Cleaner API function calls
Default Values	{ stock = 50 } = product	Handle missing data safely

✅ Object Destructuring = clean, readable, and real-world ready code.

=============================================================
Array Methods (map, filter, reduce, forEach, find, some, every, sort)
=============================================================
🔹 1. map() → Transform Each Item

👉 Returns a new array after applying a function.

📌 Example: Add tax to product prices

let products = [100, 200, 300];

// Add 18% GST to each price
let pricesWithGST = products.map(price => price + price * 0.18);

console.log(pricesWithGST); // [118, 236, 354]


✅ Use case: Updating all product prices with tax/discount.

🔹 2. filter() → Select Items Based on Condition

👉 Returns a new array with items that pass the condition.

📌 Example: Get students who passed

let students = [
  { name: "Amit", marks: 45 },
  { name: "Neha", marks: 80 },
  { name: "Raj", marks: 30 }
];

let passed = students.filter(s => s.marks >= 40);
console.log(passed);
// [ { name: 'Amit', marks: 45 }, { name: 'Neha', marks: 80 } ]


✅ Use case: Filtering students, products in stock, active users, etc.

🔹 3. reduce() → Accumulate Values

👉 Reduces an array into a single value.

📌 Example: Total bill in shopping cart

let cart = [
  { item: "Shoes", price: 2000 },
  { item: "Bag", price: 1500 },
  { item: "Watch", price: 3000 }
];

let total = cart.reduce((sum, product) => sum + product.price, 0);
console.log(`Total Bill: ₹${total}`); 
// Total Bill: ₹6500


✅ Use case: Summing cart total, salaries, votes, etc.

🔹 4. forEach() → Loop Over Each Item

👉 Executes a function for each element (no new array).

📌 Example: Notify users via email

let users = ["suraj@example.com", "neha@example.com", "amit@example.com"];

users.forEach(email => {
  console.log(`📧 Sending email to ${email}`);
});


✅ Use case: Running side effects like sending notifications, logging.

🔹 5. find() → Find First Match

👉 Returns the first item that matches condition.

📌 Example: Find employee by ID

let employees = [
  { id: 101, name: "Suraj" },
  { id: 102, name: "Neha" },
  { id: 103, name: "Raj" }
];

let emp = employees.find(e => e.id === 102);
console.log(emp); // { id: 102, name: "Neha" }


✅ Use case: Lookup in database results.

🔹 6. some() → Check if at least one item matches

👉 Returns true / false.

📌 Example: Check if any product is out of stock

let inventory = [
  { item: "Laptop", stock: 5 },
  { item: "Phone", stock: 0 },
  { item: "Tablet", stock: 3 }
];

let isOutOfStock = inventory.some(p => p.stock === 0);
console.log(isOutOfStock); // true


✅ Use case: Validate if at least one condition is true.

🔹 7. every() → Check if all items match

👉 Returns true / false.

📌 Example: Check if all students passed

let marks = [55, 60, 70, 40];

let allPassed = marks.every(m => m >= 40);
console.log(allPassed); // true


✅ Use case: Validation rules (all fields filled, all students passed).

🔹 8. sort() → Sort Array

👉 Sorts in place (changes original array).

📌 Example: Sort products by price

let items = [
  { name: "Shoes", price: 2000 },
  { name: "Watch", price: 1500 },
  { name: "Bag", price: 3000 }
];

items.sort((a, b) => a.price - b.price);

console.log(items);
// [ { name: 'Watch', price: 1500 }, { name: 'Shoes', price: 2000 }, { name: 'Bag', price: 3000 } ]


✅ Use case: Sorting products, names, scores, etc.

⚡ Summary Table
Method	Purpose	Real Use Case
map()	Transform	Add tax to prices
filter()	Select items	Find passed students
reduce()	Accumulate	Calculate shopping total
forEach()	Loop with side effects	Send emails
find()	Find first match	Get employee by ID
some()	At least one true	Any product out of stock?
every()	All must be true	Did all students pass?
sort()	Arrange items	Sort products by price

=============================================================
Array & Object Spread/Rest
=============================================================
🔹 1. Spread Operator (...)

👉 Used to expand elements of an array or properties of an object.

✅ Example 1: Array Spread → Shopping Cart 🛒
let cart1 = ["Shoes", "Watch"];
let cart2 = ["Bag", "Laptop"];

// Combine carts
let finalCart = [...cart1, ...cart2, "Sunglasses"];

console.log(finalCart);
// ["Shoes", "Watch", "Bag", "Laptop", "Sunglasses"]


✔ Real use case: Merging shopping carts.

✅ Example 2: Object Spread → Employee Update 🏢
let employee = {
  id: 101,
  name: "Suraj",
  role: "Developer"
};

// Promote employee (spread + new property)
let updatedEmployee = {
  ...employee,
  role: "Team Lead",
  department: "IT"
};

console.log(updatedEmployee);
// { id: 101, name: "Suraj", role: "Team Lead", department: "IT" }


✔ Real use case: Updating employee details without modifying original object.

✅ Example 3: Copying Arrays → Student Marks 🎓
let marks = [80, 70, 90];
let copiedMarks = [...marks]; // independent copy

copiedMarks.push(100);

console.log("Original:", marks);     // [80, 70, 90]
console.log("Copied:", copiedMarks); // [80, 70, 90, 100]


✔ Real use case: Prevent modifying original student data.

🔹 2. Rest Operator (...)

👉 Used to collect multiple elements into an array or object.

✅ Example 4: Function Parameters → Restaurant Order 🍽️
function placeOrder(customer, ...items) {
  console.log(`Customer: ${customer}`);
  console.log(`Items Ordered: ${items.join(", ")}`);
}

placeOrder("Neha", "Pizza", "Burger", "Coke");
// Customer: Neha
// Items Ordered: Pizza, Burger, Coke


✔ Real use case: Taking unlimited food orders.

✅ Example 5: Object Rest → User Data 🧑‍💻
let user = {
  id: 1,
  name: "Raj",
  email: "raj@example.com",
  password: "secret123"
};

// Extract only required data
let { password, ...publicData } = user;

console.log(publicData);
// { id: 1, name: "Raj", email: "raj@example.com" }


✔ Real use case: Hiding sensitive info (passwords) before showing user profile.

✅ Example 6: Array Destructuring with Rest → Students 🏫
let students = ["Amit", "Neha", "Raj", "Pooja"];

// First student is leader, rest are team members
let [leader, ...teamMembers] = students;

console.log("Leader:", leader);           // Amit
console.log("Team Members:", teamMembers); // ["Neha", "Raj", "Pooja"]


✔ Real use case: Assigning leader and team members.

⚡ Summary
Operator	Works in	Purpose	Real Use Case
Spread (...)	Array/Object	Expand values	Merge carts, update employee
Rest (...)	Function/Object/Array	Collect values	Order items, hide password, group team

=============================================================
JSON (JSON.stringify, JSON.parse)
=============================================================
🔹 What is JSON?

JSON (JavaScript Object Notation) → lightweight data format for storing & exchanging data.

Data is in key-value pairs (similar to JS objects).

Commonly used in APIs and databases.

🔹 1. JSON.stringify() → Convert JS Object → JSON String

📌 Example: Sending Employee Data to Server (API request)

let employee = {
  id: 101,
  name: "Suraj",
  role: "Developer",
  skills: ["JavaScript", "React", "Node.js"]
};

// Convert object to JSON string before sending to server
let jsonData = JSON.stringify(employee);

console.log(jsonData);


✅ Output:

{"id":101,"name":"Suraj","role":"Developer","skills":["JavaScript","React","Node.js"]}


✔ Real use case: Sending employee details to backend/API.

🔹 2. JSON.parse() → Convert JSON String → JS Object

📌 Example: Receiving Order Data from API (Server Response)

let orderData = '{"orderId":501,"customer":"Neha","items":["Laptop","Bag"],"total":56000}';

// Convert JSON string to JS object
let order = JSON.parse(orderData);

console.log(order.customer); // Neha
console.log(order.items[0]); // Laptop


✔ Real use case: Parsing API response to access order details.

🔹 3. Using Both Together

📌 Example: Save & Retrieve User Data in Local Storage (Browser)

// User profile object
let user = {
  id: 1,
  name: "Raj",
  email: "raj@example.com",
  isLoggedIn: true
};

// Store in localStorage (needs string format)
localStorage.setItem("user", JSON.stringify(user));

// Retrieve from localStorage
let userData = JSON.parse(localStorage.getItem("user"));

console.log(userData.name);   // Raj
console.log(userData.isLoggedIn); // true


✔ Real use case: Saving user session in browser.

🔹 4. Nested JSON Example

📌 Example: Student Report Card

let student = {
  id: 10,
  name: "Amit",
  subjects: {
    math: 90,
    science: 85,
    english: 88
  },
  passed: true
};

// Convert to JSON string
let jsonString = JSON.stringify(student);

console.log("JSON String:", jsonString);

// Parse back to object
let studentObj = JSON.parse(jsonString);

console.log("Math Marks:", studentObj.subjects.math); // 90


✔ Real use case: Storing structured data (marks, addresses, etc.) in databases/APIs.

⚡ Summary
Method	Purpose	Real Use Case
JSON.stringify(obj)	Object → JSON String	Send data to server, save in localStorage
JSON.parse(str)	JSON String → Object	Read API response, get saved data


=============================================================
6. DOM Manipulation
=============================================================
🔹 What is DOM?

DOM (Document Object Model) = A tree structure that represents HTML elements in a web page.
👉 Using JavaScript, we can select, create, update, delete, and handle events on DOM elements.

🔹 1. Selecting Elements

📌 Example: Selecting a Button

<button id="loginBtn">Login</button>

// Different ways to select elements
let btn1 = document.getElementById("loginBtn");
let btn2 = document.querySelector("#loginBtn"); // CSS selector
let btn3 = document.getElementsByTagName("button")[0];

console.log(btn1.textContent); // Login


✔ Real use case: Selecting buttons, forms, headings to manipulate them.

🔹 2. Changing Content

📌 Example: Online Exam System

<h2 id="status">Exam not started</h2>
<button onclick="startExam()">Start Exam</button>

function startExam() {
  document.getElementById("status").textContent = "Exam is running...";
}


✔ Real use case: Updating exam status dynamically.

🔹 3. Changing Styles

📌 Example: Highlight Low Stock Products

<p id="product">Laptop - Only 2 left!</p>

let product = document.getElementById("product");
product.style.color = "red";
product.style.fontWeight = "bold";


✔ Real use case: Highlight warnings, errors, discounts.

🔹 4. Creating & Adding Elements

📌 Example: Adding New Chat Message

<ul id="chatBox"></ul>

function addMessage(user, message) {
  let li = document.createElement("li");
  li.textContent = `${user}: ${message}`;
  document.getElementById("chatBox").appendChild(li);
}

addMessage("Suraj", "Hello, how are you?");


✔ Real use case: Adding chat messages, comments, notifications dynamically.

🔹 5. Removing Elements

📌 Example: Remove Item from Cart

<ul id="cart">
  <li id="item1">Shoes <button onclick="removeItem('item1')">Remove</button></li>
</ul>

function removeItem(itemId) {
  let item = document.getElementById(itemId);
  item.remove(); // or item.parentNode.removeChild(item);
}


✔ Real use case: Deleting items from shopping cart.

🔹 6. Handling Events

📌 Example: Login Button Click

<button id="loginBtn">Login</button>

let loginBtn = document.getElementById("loginBtn");

loginBtn.addEventListener("click", function() {
  alert("You clicked Login!");
});


✔ Real use case: Handling clicks, form submissions, mouseover, keypress events.

🔹 7. Changing Attributes

📌 Example: Change Profile Picture

<img id="profilePic" src="default.jpg" width="150">

document.getElementById("profilePic").setAttribute("src", "user1.jpg");


✔ Real use case: Updating image source, links, input values.

🔹 8. Form Handling

📌 Example: Get User Input

<input type="text" id="username" placeholder="Enter name">
<button onclick="showUser()">Submit</button>
<p id="output"></p>

function showUser() {
  let name = document.getElementById("username").value;
  document.getElementById("output").textContent = `Welcome, ${name}!`;
}


✔ Real use case: Taking user input from forms.

🔹 9. Class Manipulation

📌 Example: Toggle Dark Mode

<body id="page">
  <button onclick="toggleTheme()">Toggle Dark Mode</button>
</body>

function toggleTheme() {
  document.getElementById("page").classList.toggle("dark-mode");
}


✔ Real use case: Switching between light/dark mode.

⚡ Summary of DOM Manipulation
Type	Method	Real Example
Select	getElementById, querySelector	Select button, form
Content	textContent, innerHTML	Update exam status
Style	.style	Highlight low stock
Create/Add	createElement, appendChild	Add chat message
Remove	.remove()	Remove cart item
Events	addEventListener	Login button click
Attributes	setAttribute	Change profile picture
Forms	.value	Get user input
Class	classList.add/remove/toggle	Dark mode


=============================================================
Selecting Elements (getElementById, querySelector, querySelectorAll)
=============================================================
🔹 1. document.getElementById()

👉 Selects one element by its id.

📌 Example: Online Exam Portal (Change Exam Status)

<h2 id="examStatus">Exam not started</h2>
<button onclick="startExam()">Start Exam</button>

<script>
function startExam() {
  let status = document.getElementById("examStatus");
  status.textContent = "✅ Exam is now live!";
}
</script>


✅ Real use case: Updating text, button labels, or status messages.

🔹 2. document.querySelector()

👉 Selects the first matching element (using CSS selectors).

📌 Example: E-commerce Site (Highlight Discount Product)

<div class="product">Shoes - ₹2000</div>
<div class="product discount">Watch - ₹1500 (10% OFF)</div>
<div class="product">Bag - ₹3000</div>

<script>
let firstDiscount = document.querySelector(".discount");
firstDiscount.style.color = "red";
firstDiscount.style.fontWeight = "bold";
</script>


✅ Real use case: Target first matching product, form field, or element with class.

🔹 3. document.querySelectorAll()

👉 Selects all matching elements (returns a NodeList).

📌 Example: News Website (Style All Headlines)

<h2 class="headline">Breaking: Market News</h2>
<h2 class="headline">Sports: India Wins</h2>
<h2 class="headline">Weather: Rain Expected</h2>

<script>
let headlines = document.querySelectorAll(".headline");

headlines.forEach(h => {
  h.style.background = "yellow";
  h.style.padding = "5px";
});
</script>


✅ Real use case: Applying styles/actions to multiple elements (headings, cards, inputs).

⚡ Quick Comparison
Method	Selects	Example Selector	Real Use Case
getElementById	One element (by id)	"examStatus"	Update exam status
querySelector	First match (CSS selector)	".discount"	Highlight first discount
querySelectorAll	All matches (NodeList)	".headline"	Apply style to all headlines

=====================================================================
Changing Content & Styles (innerHTML, textContent, style)
=====================================================================
🔹 1. innerHTML → Change HTML Content

👉 Lets you change the HTML inside an element (can include tags).

📌 Example: E-commerce Site – Show Product Details

<div id="product"></div>
<button onclick="showProduct()">Show Product</button>

<script>
function showProduct() {
  document.getElementById("product").innerHTML = 
    "<h3>👜 Leather Bag</h3><p>Price: ₹3000</p><strong>In Stock</strong>";
}
</script>


✅ Real use case: Display product details, notifications, or formatted content.

🔹 2. textContent → Change Only Text

👉 Updates only the text, ignores HTML tags.

📌 Example: Exam System – Update Status

<h2 id="examStatus">Exam not started</h2>
<button onclick="startExam()">Start Exam</button>

<script>
function startExam() {
  document.getElementById("examStatus").textContent = 
    "✅ Exam is live! Good luck!";
}
</script>


✅ Real use case: Updating labels, messages, or preventing unwanted HTML injection.

🔹 3. style → Change CSS Styles

👉 Allows you to change inline CSS styles dynamically.

📌 Example: Stock Management – Highlight Low Stock Items

<p id="stock">⚠️ Only 2 Laptops left!</p>
<button onclick="highlight()">Highlight</button>

<script>
function highlight() {
  let stock = document.getElementById("stock");
  stock.style.color = "red";
  stock.style.fontWeight = "bold";
  stock.style.background = "yellow";
}
</script>


✅ Real use case: Highlighting errors, warnings, offers, or themes (dark mode).

⚡ Quick Comparison
Method	Purpose	Can Handle HTML?	Real Use Case
innerHTML	Set/replace HTML content	✅ Yes	Display product details
textContent	Set/retrieve plain text	❌ No	Update exam status
style	Modify inline CSS styles	❌ N/A	Highlight low stock

=====================================================================
Adding & Removing Elements (appendChild, remove, insertBefore)
=====================================================================
🔹 1. appendChild() → Add New Element at the End

📌 Example: Chat Application – Add New Message

<ul id="chatBox"></ul>
<button onclick="sendMessage()">Send Message</button>

<script>
function sendMessage() {
  let li = document.createElement("li");  // create new list item
  li.textContent = "Suraj: Hello, how are you?";
  document.getElementById("chatBox").appendChild(li);
}
</script>


✅ Real use case: Adding chat messages, comments, notifications dynamically.

🔹 2. remove() → Remove an Element

📌 Example: Shopping Cart – Remove Item

<ul id="cart">
  <li id="item1">Shoes <button onclick="removeItem('item1')">Remove</button></li>
  <li id="item2">Bag <button onclick="removeItem('item2')">Remove</button></li>
</ul>

<script>
function removeItem(itemId) {
  document.getElementById(itemId).remove();
}
</script>


✅ Real use case: Deleting items from cart, removing posts, clearing fields.

🔹 3. insertBefore() → Insert New Element Before Another

📌 Example: Task List – Add Urgent Task Before First Task

<ul id="tasks">
  <li>Do Homework</li>
  <li>Clean Room</li>
</ul>
<button onclick="addUrgentTask()">Add Urgent Task</button>

<script>
function addUrgentTask() {
  let li = document.createElement("li");
  li.textContent = "🔥 Submit Project Report";

  let taskList = document.getElementById("tasks");
  let firstTask = taskList.firstElementChild; // first task
  taskList.insertBefore(li, firstTask);       // insert before first
}
</script>


✅ Real use case: Prioritizing tasks, inserting ads before posts, showing urgent alerts.

⚡ Quick Comparison
Method	Action	Real Example
appendChild()	Adds new element at end	Add chat message
remove()	Removes element	Remove cart item
insertBefore()	Inserts before specific element	Insert urgent task

=====================================================================
Attributes & Classes (setAttribute, classList)
=====================================================================
🔹 1. setAttribute() → Set or Change an Attribute

📌 Example: Change Profile Picture Dynamically

<img id="profilePic" src="default.jpg" alt="Profile" width="150">
<button onclick="changePic()">Change Picture</button>

<script>
function changePic() {
  let img = document.getElementById("profilePic");
  img.setAttribute("src", "user.jpg"); // change image
  img.setAttribute("alt", "User Profile");
}
</script>


✅ Real use case: Update image, link, input attributes dynamically (e.g., when user uploads profile photo).

🔹 2. classList.add() → Add a Class

📌 Example: Highlight Error Input

<input type="text" id="username" placeholder="Enter username">
<button onclick="showError()">Submit</button>

<script>
function showError() {
  let input = document.getElementById("username");
  input.classList.add("error"); // add error class
}
</script>

<style>
.error {
  border: 2px solid red;
  background: #ffe5e5;
}
</style>


✅ Real use case: Highlight invalid form fields.

🔹 3. classList.remove() → Remove a Class

📌 Example: Hide Notification After Closing

<div id="notification" class="alert">New message received! 
  <button onclick="closeNotification()">X</button>
</div>

<script>
function closeNotification() {
  document.getElementById("notification").classList.remove("alert");
}
</script>

<style>
.alert {
  padding: 10px;
  background: yellow;
  border: 1px solid orange;
}
</style>


✅ Real use case: Remove highlight, hide popups, clear validation messages.

🔹 4. classList.toggle() → Switch Class On/Off

📌 Example: Dark Mode Toggle

<button onclick="toggleTheme()">Toggle Dark Mode</button>
<p id="text">Hello, this is my website!</p>

<script>
function toggleTheme() {
  document.body.classList.toggle("dark");
}
</script>

<style>
.dark {
  background: black;
  color: white;
}
</style>


✅ Real use case: Light/Dark mode switch, show/hide menus.

🔹 5. classList.contains() → Check if Class Exists

📌 Example: Prevent Duplicate Styling

<div id="box">I am a box</div>
<button onclick="highlightBox()">Highlight Box</button>

<script>
function highlightBox() {
  let box = document.getElementById("box");
  if (!box.classList.contains("highlight")) {
    box.classList.add("highlight");
  }
}
</script>

<style>
.highlight {
  border: 3px solid green;
  padding: 10px;
}
</style>


✅ Real use case: Prevent duplicate styling or repeated animations.

⚡ Summary
Method	Action	Real Use Case
setAttribute(name,val)	Sets/changes attribute	Change profile pic dynamically
classList.add()	Adds class	Show validation error
classList.remove()	Removes class	Hide notification
classList.toggle()	Toggles class	Dark mode switch
classList.contains()	Checks class	Avoid duplicate style

=====================================================================
Event Handling (addEventListener, event bubbling, delegation)
=====================================================================
🔹 1. addEventListener() → Attach Multiple Event Listeners

📌 Example: Button Click & Mouseover

<button id="buyBtn">Buy Now</button>

<script>
let btn = document.getElementById("buyBtn");

// Click event
btn.addEventListener("click", function() {
  alert("Item added to cart!");
});

// Mouse hover event
btn.addEventListener("mouseover", function() {
  btn.style.background = "lightgreen";
});
</script>


✅ Real use case: Attach multiple events (click, hover, focus) to a button without overwriting.

🔹 2. Event Bubbling → Event flows from child → parent

📌 Example: Clicking a Child Triggers Parent Too

<div id="parent" style="padding:20px; background:#f1f1f1;">
  Parent Div
  <button id="child">Click Me</button>
</div>

<script>
document.getElementById("parent").addEventListener("click", function() {
  alert("Parent Div Clicked!");
});

document.getElementById("child").addEventListener("click", function() {
  alert("Child Button Clicked!");
});
</script>


🔎 If you click Child Button:

First → "Child Button Clicked!"

Then → "Parent Div Clicked!" (because of bubbling)

✅ Real use case: Detect clicks both on items and their containers (like clicking product + product card).

🔹 3. Event Delegation → Handle Events on Parent Instead of Each Child

📌 Example: Shopping Cart (Multiple Buttons)

<ul id="productList">
  <li><button class="addToCart">Add Apple</button></li>
  <li><button class="addToCart">Add Mango</button></li>
  <li><button class="addToCart">Add Orange</button></li>
</ul>

<script>
document.getElementById("productList").addEventListener("click", function(event) {
  if (event.target.classList.contains("addToCart")) {
    alert(event.target.innerText + " clicked!");
  }
});
</script>


✅ Real use case: Instead of attaching event listeners to each product button, attach one listener to the parent <ul> → saves performance in large lists.

⚡ Summary
Concept	Meaning	Real Use Case
addEventListener()	Attach events (multiple allowed)	Button click, hover
Event Bubbling	Events propagate child → parent	Modal close when clicking outside
Event Delegation	Use parent to handle child events	Shopping cart, menus, chat apps

=====================================================================
7. Advanced JavaScript (Done)
=====================================================================
🔹 1. Closures

📌 A function “remembers” variables from its outer scope, even after the outer function has finished.

Example: Banking App – Balance Privacy

function createAccount(initialBalance) {
  let balance = initialBalance; // private variable

  return {
    deposit: function(amount) {
      balance += amount;
      return `Deposited ₹${amount}, New Balance: ₹${balance}`;
    },
    withdraw: function(amount) {
      if (amount <= balance) {
        balance -= amount;
        return `Withdrawn ₹${amount}, Remaining Balance: ₹${balance}`;
      } else {
        return "Insufficient funds!";
      }
    }
  };
}

const myAccount = createAccount(500);
console.log(myAccount.deposit(200)); // Deposited ₹200, New Balance: ₹700
console.log(myAccount.withdraw(1000)); // Insufficient funds!


✅ Real use case → Keeping data private in apps (like bank balance).

🔹 2. Promises & Async/Await

📌 Handle asynchronous operations (e.g., API calls, DB queries).

Example: Fetch Weather Data

// Using Promise
function fetchWeather(city) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (city === "Pune") {
        resolve("☀️ Sunny in Pune");
      } else {
        reject("City not found!");
      }
    }, 1000);
  });
}

// Using async/await
async function showWeather() {
  try {
    let result = await fetchWeather("Pune");
    console.log(result); 
  } catch (error) {
    console.log(error);
  }
}

showWeather();


✅ Real use case → APIs in weather apps, payment processing.

🔹 3. Event Loop & Concurrency

📌 JS executes code line by line (single-threaded), but async tasks go to event loop queue.

Example: Order Food App

console.log("1. Place order 🍔");

setTimeout(() => console.log("2. Cooking food ⏳"), 2000);

console.log("3. Continue scrolling Instagram 📱");


Output order:

1. Place order 🍔
3. Continue scrolling Instagram 📱
2. Cooking food ⏳


✅ Real use case → Non-blocking apps (chat apps, food ordering).

🔹 4. Prototypes & Inheritance

📌 Objects inherit properties/methods via prototype chain.

Example: Vehicle Inheritance

function Vehicle(type) {
  this.type = type;
}
Vehicle.prototype.drive = function() {
  return `${this.type} is moving 🚗`;
};

function Car(model) {
  Vehicle.call(this, "Car");
  this.model = model;
}
Car.prototype = Object.create(Vehicle.prototype);

const myCar = new Car("Tesla");
console.log(myCar.drive()); // Car is moving 🚗


✅ Real use case → Reuse code in OOP design.

🔹 5. Modules (import/export)

📌 Split code into files for better maintainability.

Example: E-commerce Cart

📁 cart.js

export function addToCart(item) {
  return `${item} added to cart 🛒`;
}


📁 app.js

import { addToCart } from './cart.js';

console.log(addToCart("Laptop")); // Laptop added to cart 🛒


✅ Real use case → Modular code in projects (React, Node.js).

🔹 6. Currying

📌 Break a function with multiple arguments into smaller functions.

Example: Online Order Discount

function applyDiscount(discount) {
  return function(price) {
    return price - (price * discount);
  };
}

let studentDiscount = applyDiscount(0.2);
console.log(studentDiscount(1000)); // 800


✅ Real use case → Reusable functions (discounts, tax calculation).

🔹 7. Debouncing & Throttling

📌 Improve performance by controlling how often a function runs.

Example: Search Suggestions (Debouncing)

let timer;
function search(query) {
  clearTimeout(timer);
  timer = setTimeout(() => {
    console.log("Searching for:", query);
  }, 500);
}

// Simulating typing
search("a");
search("ap");
search("app");


✅ Real use case → Google search suggestions, scroll events.

🔹 8. LocalStorage & SessionStorage

📌 Store data in the browser.

Example: Remember User Login

// Save login
localStorage.setItem("username", "Suraj");

// Retrieve
console.log(localStorage.getItem("username")); // Suraj

// Remove
localStorage.removeItem("username");


✅ Real use case → Store theme, login state, cart items.

⚡ Summary (Advanced JS Topics)

✅ Closures → Private variables (Bank account)
✅ Promises/Async → Handle async (Weather API)
✅ Event Loop → Non-blocking tasks (Food app)
✅ Prototypes → Inheritance (Car from Vehicle)
✅ Modules → Split files (Cart system)
✅ Currying → Reuse functions (Discounts)
✅ Debounce/Throttle → Performance (Search, scroll)
✅ Storage → Save data (Login, theme, cart)

=====================================================================
ES6+ Features (let/const, template literals, destructuring, modules, etc.)
=====================================================================
🔹 1. let & const

📌 Block-scoped, unlike var.

Example: Shopping Cart Item Count

let itemsInCart = 3;
const maxItems = 10;

if (itemsInCart < maxItems) {
  let newItem = "Laptop";
  console.log(`${newItem} added to cart 🛒`);
}

// ❌ newItem is not accessible here (block scope)


✅ Real use case → Prevent accidental variable overwrites.

🔹 2. Template Literals (Backticks ``)

📌 Easier string concatenation + multi-line strings.

Example: Invoice Generation

let customer = "Suraj";
let amount = 1500;

let invoice = `Hello ${customer}, 
Your total bill is ₹${amount}.
Thank you for shopping!`;

console.log(invoice);


✅ Real use case → Create formatted messages, emails, invoices.

🔹 3. Object & Array Destructuring

📌 Extract values easily.

Example: User Profile Data

let user = { name: "Riya", age: 25, city: "Pune" };
let { name, city } = user;

console.log(`${name} lives in ${city}`); // Riya lives in Pune

let fruits = ["Apple", "Mango", "Banana"];
let [first, , third] = fruits;

console.log(first, third); // Apple Banana


✅ Real use case → Handle API responses easily.

🔹 4. Default Parameters

📌 Provide fallback values.

Example: Food Delivery Charges

function orderFood(item, deliveryCharge = 50) {
  return `${item} ordered with delivery charge ₹${deliveryCharge}`;
}

console.log(orderFood("Pizza"));      // delivery charge ₹50
console.log(orderFood("Burger", 0));  // free delivery


✅ Real use case → Optional function arguments.

🔹 5. Arrow Functions () => {}

📌 Shorter syntax + lexical this.

Example: Filter Online Users

let users = [
  { name: "Amit", online: true },
  { name: "Sneha", online: false }
];

let onlineUsers = users.filter(user => user.online);
console.log(onlineUsers); // [{ name: "Amit", online: true }]


✅ Real use case → Clean callbacks (map, filter, reduce).

🔹 6. Spread Operator ...

📌 Expand arrays/objects.

Example: Combine Two Shopping Carts

let cart1 = ["Laptop", "Phone"];
let cart2 = ["Headphones", "Charger"];

let mergedCart = [...cart1, ...cart2];
console.log(mergedCart); 
// ["Laptop", "Phone", "Headphones", "Charger"]


✅ Real use case → Merge lists, clone objects.

🔹 7. Rest Operator ...

📌 Collect remaining arguments.

Example: Restaurant Bill Split

function splitBill(person1, person2, ...others) {
  console.log(`Main payers: ${person1}, ${person2}`);
  console.log(`Others: ${others.join(", ")}`);
}

splitBill("Amit", "Riya", "Suraj", "Sneha", "Priya");
// Main payers: Amit, Riya
// Others: Suraj, Sneha, Priya


✅ Real use case → Flexible functions (multiple inputs).

🔹 8. Modules (import/export)

📌 Organize code into files.

Example: Online Store

📁 cart.js

export function addToCart(item) {
  return `${item} added to cart 🛒`;
}


📁 app.js

import { addToCart } from './cart.js';

console.log(addToCart("Laptop")); // Laptop added to cart 🛒


✅ Real use case → Modular, maintainable apps.

🔹 9. Classes

📌 OOP-style syntax in JS.

Example: Online Booking System

class Booking {
  constructor(name, seat) {
    this.name = name;
    this.seat = seat;
  }
  confirm() {
    return `Booking confirmed for ${this.name}, Seat: ${this.seat}`;
  }
}

let ticket = new Booking("Suraj", "A12");
console.log(ticket.confirm());


✅ Real use case → Reusable blueprints (Bookings, Orders, Users).

🔹 10. Promises & Async/Await

📌 Handle async tasks cleanly.

Example: Fetching Movie Data

function fetchMovie() {
  return new Promise(resolve => {
    setTimeout(() => resolve("🎬 Movie: Interstellar"), 1000);
  });
}

async function showMovie() {
  let movie = await fetchMovie();
  console.log(movie);
}

showMovie();


✅ Real use case → API calls in apps.

⚡ Summary (ES6+ Features in Real Life)
Feature	Real Use Case
let/const	Prevent overwrites in cart
Template Literals	Invoices, notifications
Destructuring	API responses, configs
Default Parameters	Delivery charges, defaults
Arrow Functions	Clean callbacks
Spread Operator	Merge carts, clone data
Rest Operator	Handle multiple inputs
Modules	Organized code
Classes	Bookings, orders, models
Async/Await	Fetch API data

=====================================================================
Spread & Rest Operator
=====================================================================
🔹 1. Spread Operator (...)
✅ Example 1: Merging Shopping Carts
let cart1 = ["Laptop", "Phone"];
let cart2 = ["Headphones", "Charger"];

let mergedCart = [...cart1, ...cart2];
console.log(mergedCart);
// ["Laptop", "Phone", "Headphones", "Charger"]


📌 Real Use Case: Merging multiple shopping carts in an e-commerce website.

✅ Example 2: Copying an Object (User Profile)
let user = { name: "Suraj", age: 25 };
let updatedUser = { ...user, city: "Pune" };

console.log(updatedUser);
// { name: "Suraj", age: 25, city: "Pune" }


📌 Real Use Case: Cloning objects and adding extra details (like when updating user profiles).

✅ Example 3: Passing Array Values to Function
function calculateBill(a, b, c) {
  return a + b + c;
}

let prices = [100, 200, 300];
console.log(calculateBill(...prices)); // 600


📌 Real Use Case: Expanding price arrays when calculating total bills.

🔹 2. Rest Operator (...)
✅ Example 1: Restaurant Bill Split
function splitBill(mainPayer, ...others) {
  console.log(`Main payer: ${mainPayer}`);
  console.log(`Others sharing: ${others.join(", ")}`);
}

splitBill("Amit", "Riya", "Sneha", "Suraj");
// Main payer: Amit
// Others sharing: Riya, Sneha, Suraj


📌 Real Use Case: Handling variable number of arguments (bill splitting, group payments).

✅ Example 2: Extracting Remaining Properties
let user = { name: "Riya", age: 24, city: "Mumbai", country: "India" };

let { name, ...details } = user;
console.log(name);     // Riya
console.log(details);  // { age: 24, city: "Mumbai", country: "India" }


📌 Real Use Case: Get required property (name) and keep the rest (user details).

✅ Example 3: Dynamic Sum of Numbers
function totalAmount(...amounts) {
  return amounts.reduce((sum, amt) => sum + amt, 0);
}

console.log(totalAmount(200, 500, 300, 100)); // 1100


📌 Real Use Case: Summing variable number of payments in a payment app.

⚡ Key Difference
Operator	Meaning	Example Use Case
Spread	Expands array/object	Merge shopping carts, clone user profile
Rest	Collects arguments into array	Split bills, dynamic functions, extract details

=====================================================================
Default & Named Exports / Imports
=====================================================================
🔹 1. Named Exports / Imports

📌 You can export multiple functions/variables from a file.
📌 Import them using curly braces {}.

✅ Example: mathUtils.js
// Named Exports
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

export const TAX_RATE = 0.18;

✅ Example: app.js
// Named Imports
import { add, subtract, TAX_RATE } from './mathUtils.js';

console.log(add(10, 5));        // 15
console.log(subtract(10, 5));   // 5
console.log("Tax Rate:", TAX_RATE); // 0.18


📌 Real Use Case → Utility functions for billing, tax calculation, discounts.

🔹 2. Default Exports / Imports

📌 Each file can have only one default export.
📌 Import without curly braces.

✅ Example: payment.js
// Default Export
export default function processPayment(amount) {
  return `Payment of ₹${amount} processed successfully ✅`;
}

✅ Example: app.js
// Default Import
import processPayment from './payment.js';

console.log(processPayment(1500));
// Payment of ₹1500 processed successfully ✅


📌 Real Use Case → One main function/class per module (like a payment processor).

🔹 3. Mixing Default & Named Exports
✅ Example: cart.js
export default function addToCart(item) {
  return `${item} added to cart 🛒`;
}

export function removeFromCart(item) {
  return `${item} removed from cart ❌`;
}

export const SHIPPING_CHARGE = 50;

✅ Example: app.js
// Import default + named exports
import addToCart, { removeFromCart, SHIPPING_CHARGE } from './cart.js';

console.log(addToCart("Laptop"));      
// Laptop added to cart 🛒

console.log(removeFromCart("Laptop")); 
// Laptop removed from cart ❌

console.log("Shipping:", SHIPPING_CHARGE); 
// Shipping: 50


📌 Real Use Case →

default → Primary feature (addToCart).

named → Extra utilities (removeFromCart, SHIPPING_CHARGE).

⚡ Summary
Export Type	Import Syntax	Use Case
Named Export	import { fn } from	Multiple utilities from one file
Default Export	import fn from	One main feature per file
Mixing Both	import fn, { utils }	Main + extra features

=====================================================================
Promises (then, catch, finally)
=====================================================================
🔹 What is a Promise?

A Promise in JavaScript is an object that represents the eventual completion (resolved) or failure (rejected) of an asynchronous operation.

It has 3 states:

Pending – still working.

Fulfilled (Resolved) – success.

Rejected – failure.

🔹 Syntax
new Promise((resolve, reject) => {
  // async work
  if (success) resolve(value);
  else reject(error);
})

🔹 Real-World Examples
✅ Example 1: Online Food Order
function orderFood(item) {
  return new Promise((resolve, reject) => {
    console.log(`Ordering ${item}... 🍔`);
    setTimeout(() => {
      if (item === "Pizza") {
        resolve("Pizza delivered! ✅");
      } else {
        reject("Sorry, item not available ❌");
      }
    }, 2000);
  });
}

orderFood("Pizza")
  .then(response => {
    console.log("Success:", response);
  })
  .catch(error => {
    console.log("Error:", error);
  })
  .finally(() => {
    console.log("Thank you for ordering with us 🙏");
  });

🔎 Output if item = "Pizza":
Ordering Pizza... 🍔
Success: Pizza delivered! ✅
Thank you for ordering with us 🙏

🔎 Output if item = "Burger":
Ordering Burger... 🍔
Error: Sorry, item not available ❌
Thank you for ordering with us 🙏


📌 Real Use Case → Food delivery apps (Zomato, Swiggy).

✅ Example 2: Payment Gateway
function processPayment(amount) {
  return new Promise((resolve, reject) => {
    console.log("Processing payment of ₹" + amount);
    setTimeout(() => {
      let success = Math.random() > 0.3; // 70% chance success
      success ? resolve("Payment Successful ✅") : reject("Payment Failed ❌");
    }, 1500);
  });
}

processPayment(1000)
  .then(msg => console.log(msg))
  .catch(err => console.log(err))
  .finally(() => console.log("Transaction Complete 🏦"));


📌 Real Use Case → Handling payments in online shopping apps.

✅ Example 3: Fetch User Data (API Simulation)
function fetchUser(id) {
  return new Promise((resolve, reject) => {
    console.log("Fetching user data...");
    setTimeout(() => {
      if (id === 1) {
        resolve({ id: 1, name: "Suraj", role: "Admin" });
      } else {
        reject("User not found!");
      }
    }, 1000);
  });
}

fetchUser(1)
  .then(user => console.log("User Data:", user))
  .catch(err => console.log("Error:", err))
  .finally(() => console.log("API call finished ✅"));


📌 Real Use Case → Fetching user details from server.

⚡ Summary
Method	Purpose	Example Use Case
then()	Runs when Promise is resolved (success)	Show order delivered message
catch()	Runs when Promise is rejected (error)	Show error in payment
finally()	Runs always (success or fail)	Close loaders, thank message

=====================================================================
Async/Await
=====================================================================
🔹 What is async/await?

async/await is a cleaner and more readable way to work with Promises.

Instead of chaining .then() and .catch(), you can write asynchronous code like synchronous code.

🔹 Rules

async keyword → makes a function return a Promise.

await keyword → pauses the function until the Promise is resolved or rejected.

Use try...catch for error handling.

🔹 Real-World Examples
✅ Example 1: Online Food Order (Async/Await)
function orderFood(item) {
  return new Promise((resolve, reject) => {
    console.log(`Ordering ${item}... 🍔`);
    setTimeout(() => {
      if (item === "Pizza") {
        resolve("Pizza delivered! ✅");
      } else {
        reject("Sorry, item not available ❌");
      }
    }, 2000);
  });
}

async function placeOrder() {
  try {
    let result = await orderFood("Pizza");
    console.log("Success:", result);
  } catch (error) {
    console.log("Error:", error);
  } finally {
    console.log("Thank you for ordering with us 🙏");
  }
}

placeOrder();


📌 Cleaner than .then().catch().finally()

✅ Example 2: Payment Gateway (Async/Await)
function processPayment(amount) {
  return new Promise((resolve, reject) => {
    console.log("Processing payment of ₹" + amount);
    setTimeout(() => {
      let success = Math.random() > 0.3; // 70% chance success
      success ? resolve("Payment Successful ✅") : reject("Payment Failed ❌");
    }, 1500);
  });
}

async function makePayment() {
  try {
    let status = await processPayment(1000);
    console.log(status);
  } catch (err) {
    console.log(err);
  } finally {
    console.log("Transaction Complete 🏦");
  }
}

makePayment();


📌 Looks like synchronous flow but still async.

✅ Example 3: Fetch User Data (API Simulation)
function fetchUser(id) {
  return new Promise((resolve, reject) => {
    console.log("Fetching user data...");
    setTimeout(() => {
      if (id === 1) {
        resolve({ id: 1, name: "Suraj", role: "Admin" });
      } else {
        reject("User not found!");
      }
    }, 1000);
  });
}

async function getUser() {
  try {
    let user = await fetchUser(1);
    console.log("User Data:", user);
  } catch (err) {
    console.log("Error:", err);
  } finally {
    console.log("API call finished ✅");
  }
}

getUser();


📌 Perfect for working with APIs (like fetch() in real apps).

⚡ Comparison: then/catch vs async/await
Feature	then/catch	async/await
Readability	More callbacks (nested)	Cleaner, looks synchronous
Error Handling	catch()	try...catch
Usage	Useful for chaining	Useful for step-by-step async tasks
Real World	API calls, payment, orders	Same, but easier to manage

=====================================================================
Fetch API & AJAX
=====================================================================
🔹 1. What is AJAX?

AJAX (Asynchronous JavaScript and XML) is a technique to send & receive data asynchronously from a server without reloading the page.

Old way → XMLHttpRequest (XHR).

Modern way → fetch() API (simpler, Promise-based).

🔹 2. Fetch API Basics
fetch("https://api.example.com/data")
  .then(response => response.json()) // Convert to JSON
  .then(data => console.log(data))   // Use the data
  .catch(error => console.error("Error:", error));

🔹 3. Real-World Examples
✅ Example 1: Fetch Weather Data 🌦️
<!DOCTYPE html>
<html>
<head>
  <title>Weather App</title>
</head>
<body>
  <h2>🌤️ Check Weather</h2>
  <button id="getWeather">Get Weather</button>
  <p id="weatherResult"></p>

  <script>
    document.getElementById("getWeather").addEventListener("click", () => {
      fetch("https://api.open-meteo.com/v1/forecast?latitude=18.5204&longitude=73.8567&current_weather=true")
        .then(response => response.json())
        .then(data => {
          document.getElementById("weatherResult").textContent =
            `Temperature in Pune: ${data.current_weather.temperature}°C 🌡️`;
        })
        .catch(error => console.error("Error fetching weather:", error));
    });
  </script>
</body>
</html>


📌 Real Use Case → Weather apps like AccuWeather.

✅ Example 2: Fetch GitHub User Profile 👨‍💻
<!DOCTYPE html>
<html>
<head>
  <title>GitHub User</title>
</head>
<body>
  <h2>🔍 Search GitHub User</h2>
  <input type="text" id="username" placeholder="Enter GitHub username">
  <button id="search">Search</button>
  <div id="profile"></div>

  <script>
    document.getElementById("search").addEventListener("click", () => {
      let user = document.getElementById("username").value;

      fetch(`https://api.github.com/users/${user}`)
        .then(response => response.json())
        .then(data => {
          document.getElementById("profile").innerHTML = `
            <p>Name: ${data.name}</p>
            <p>Followers: ${data.followers}</p>
            <img src="${data.avatar_url}" width="100">
          `;
        })
        .catch(error => console.error("Error fetching user:", error));
    });
  </script>
</body>
</html>


📌 Real Use Case → GitHub search apps.

✅ Example 3: Submitting a Contact Form (POST Request) 📩
<!DOCTYPE html>
<html>
<head>
  <title>Contact Form</title>
</head>
<body>
  <h2>📬 Contact Us</h2>
  <form id="contactForm">
    <input type="text" id="name" placeholder="Your Name" required><br><br>
    <input type="email" id="email" placeholder="Your Email" required><br><br>
    <button type="submit">Send</button>
  </form>
  <p id="result"></p>

  <script>
    document.getElementById("contactForm").addEventListener("submit", function(e) {
      e.preventDefault();

      let formData = {
        name: document.getElementById("name").value,
        email: document.getElementById("email").value
      };

      fetch("https://jsonplaceholder.typicode.com/posts", {
        method: "POST",
        body: JSON.stringify(formData),
        headers: { "Content-Type": "application/json" }
      })
      .then(response => response.json())
      .then(data => {
        document.getElementById("result").textContent = 
          "Thank you, " + data.name + "! Your message has been sent ✅";
      })
      .catch(error => console.error("Error sending form:", error));
    });
  </script>
</body>
</html>


📌 Real Use Case → Contact forms, feedback submission.

🔹 4. AJAX with XMLHttpRequest (Old Way)
let xhr = new XMLHttpRequest();
xhr.open("GET", "https://jsonplaceholder.typicode.com/posts/1", true);

xhr.onload = function() {
  if (xhr.status === 200) {
    console.log("Response:", JSON.parse(xhr.responseText));
  } else {
    console.log("Error:", xhr.status);
  }
};

xhr.send();


📌 Rarely used now, replaced by fetch().

⚡ Summary

AJAX = technique for async data (can use XHR or Fetch).

Fetch API = modern Promise-based way.

Real use cases:
✅ Weather apps
✅ GitHub profile search
✅ Contact form submission

=====================================================================
Event Loop & Concurrency Model
=====================================================================
🔹 1. What is the Event Loop?

JavaScript is single-threaded, meaning it executes one task at a time.

But JS can handle asynchronous tasks (like API calls, timers) using the Event Loop.

The Event Loop checks the call stack and message queue to execute tasks in the correct order.

Key Components:

Call Stack → Where functions are executed (synchronous code).

Web APIs → Browser APIs (like setTimeout, fetch) handle async tasks.

Callback Queue / Task Queue → Holds async callbacks.

Event Loop → Moves tasks from queue to stack when the stack is empty.

🔹 2. Real-Based Examples
✅ Example 1: setTimeout & Synchronous Code
console.log("1. Start Cooking 🍳");

setTimeout(() => {
  console.log("2. Food is Ready 🍲");
}, 2000);

console.log("3. Scroll Instagram 📱");

🔎 Output:
1. Start Cooking 🍳
3. Scroll Instagram 📱
2. Food is Ready 🍲


Explanation:

Synchronous code (console.log) runs first → goes to call stack.

setTimeout callback goes to Web APIs, then to callback queue after 2 sec.

Event Loop executes it after stack is empty.

📌 Real Use Case: Loading spinners while fetching data asynchronously.

✅ Example 2: API Call Simulation (Promise)
console.log("1. Place Order 🍔");

fetch("https://jsonplaceholder.typicode.com/todos/1")
  .then(response => response.json())
  .then(data => console.log("2. Order Delivered:", data));

console.log("3. Check Notifications 🔔");

🔎 Output:
1. Place Order 🍔
3. Check Notifications 🔔
2. Order Delivered: {userId: 1, id: 1, title: "delectus aut ...", completed: false}


Explanation:

fetch() is asynchronous → handled by Web API.

.then() callback waits in the microtask queue → executed after stack is empty.

📌 Real Use Case: Async API calls in web apps (e-commerce, social media).

✅ Example 3: setTimeout vs Promise (Microtasks vs Macrotasks)
console.log("Start 🔥");

setTimeout(() => console.log("Timeout ⏰"), 0);

Promise.resolve().then(() => console.log("Promise ✅"));

console.log("End 🏁");

🔎 Output:
Start 🔥
End 🏁
Promise ✅
Timeout ⏰


Explanation:

Promises go to microtask queue → executed before setTimeout (macrotask).

Even if setTimeout = 0ms, it runs after microtasks.

📌 Real Use Case: Handling UI updates before delayed tasks.

✅ Example 4: Real-Life Analogy (Food Delivery App)

User places order → goes call stack.

Order sent to kitchen → Web API (async).

User scrolls app → synchronous code executes.

Kitchen prepares food → callback in queue.

Event Loop moves callback → console shows “Food Ready”.

⚡ Summary
Concept	Description	Real Use Case
Call Stack	Executes synchronous code	Button click handler
Web APIs	Handles async tasks	setTimeout, fetch
Callback Queue	Holds async callbacks	API responses
Event Loop	Moves tasks from queue → stack	Non-blocking UI updates
Microtask vs Macrotask	Promise vs setTimeout	UI before delayed tasks

✅ Key Takeaway: JS never blocks the UI while waiting for async tasks.

=====================================================================
JavaScript Engine (V8 basics)
=====================================================================
🔹 1. What is a JavaScript Engine?

A JavaScript Engine is a program that reads, parses, and executes JavaScript code.

Converts JS code into machine code that your computer can understand.

Examples:

V8 → Chrome, Node.js

SpiderMonkey → Firefox

JavaScriptCore → Safari

🔹 2. How V8 Works (Basics)

V8 engine has several components:

Parser → Reads your JS code and creates an Abstract Syntax Tree (AST).

Interpreter (Ignition) → Converts AST into bytecode (fast initial execution).

Compiler (TurboFan) → Optimizes bytecode to machine code for better performance.

Garbage Collector → Frees memory used by objects no longer needed.

🔹 3. Real-Based Examples
✅ Example 1: Synchronous vs Asynchronous Execution
console.log("1. Start Task");

setTimeout(() => {
  console.log("2. Async Task Finished");
}, 1000);

console.log("3. Continue Task");


Output:

1. Start Task
3. Continue Task
2. Async Task Finished


Explanation (V8 internals):

console.log → executed by V8’s interpreter.

setTimeout → handled by Web API, callback queued.

Event Loop triggers callback → V8 executes it later.

📌 Real Use Case: Non-blocking UI updates (like scrolling while fetching data).

✅ Example 2: Just-In-Time (JIT) Compilation
function sumArray(arr) {
  return arr.reduce((acc, val) => acc + val, 0);
}

let nums = [1, 2, 3, 4, 5];
console.log(sumArray(nums));


Explanation (V8 internals):

V8 interprets the function initially.

If sumArray runs multiple times → TurboFan compiler optimizes it into machine code for faster execution.

📌 Real Use Case: Performance-critical functions in apps (calculating totals in e-commerce).

✅ Example 3: Garbage Collection
function createUser(name) {
  let user = { name };
  return user;
}

let user1 = createUser("Suraj");
user1 = null; // previous object eligible for garbage collection


Explanation (V8 internals):

The object { name: "Suraj" } is now unreachable.

V8’s garbage collector will free memory automatically.

📌 Real Use Case: Prevent memory leaks in long-running web apps (like dashboards).

✅ Example 4: Inline Caching (Optimization)
function getUserName(user) {
  return user.name;
}

let u1 = { name: "Amit" };
let u2 = { name: "Sneha" };

console.log(getUserName(u1));
console.log(getUserName(u2));


Explanation:

V8 stores hidden classes for objects.

Accessing user.name repeatedly → faster due to inline caching.

📌 Real Use Case: Optimized property access in large datasets.

⚡ Summary (V8 Real-World Concepts)
Feature	What it Does	Example Use Case
Parser	Creates AST	Reading code
Interpreter	Converts JS → bytecode	console.log
JIT Compiler (TurboFan)	Optimizes to machine code	sumArray repeatedly
Event Loop Execution	Async tasks	setTimeout, fetch
Garbage Collector	Frees unused memory	Nullifying objects
Hidden Classes / Inline Caching	Optimized property access	User objects, e-commerce data

✅ Key Takeaways:

V8 makes JS fast via interpretation + JIT compilation.

Handles async tasks efficiently.

Memory management and optimizations happen automatically.

=====================================================================
8. Object-Oriented Programming (OOP) 
=====================================================================
🔹 1. What is OOP in JavaScript?

OOP is a programming paradigm that organizes code using objects and classes.
Core Concepts:

Class → Blueprint for creating objects.

Object → Instance of a class.

Constructor → Special method to initialize object properties.

Methods → Functions inside objects/classes.

Inheritance → Child class can inherit properties/methods of parent class.

Encapsulation → Keep data safe inside the object.

Polymorphism → Same method behaves differently based on context.

🔹 2. Real-Based Examples
✅ Example 1: Classes & Objects (Online Shopping)
class Product {
  constructor(name, price) {
    this.name = name;
    this.price = price;
  }

  getDetails() {
    return `${this.name} costs ₹${this.price}`;
  }
}

// Creating objects
let laptop = new Product("Laptop", 45000);
let phone = new Product("Phone", 15000);

console.log(laptop.getDetails()); // Laptop costs ₹45000
console.log(phone.getDetails());  // Phone costs ₹15000


📌 Real Use Case: E-commerce apps → Represent products with properties & methods.

✅ Example 2: Inheritance (Customer & Premium Customer)
class Customer {
  constructor(name) {
    this.name = name;
  }
  greet() {
    return `Hello, ${this.name}!`;
  }
}

// PremiumCustomer inherits Customer
class PremiumCustomer extends Customer {
  constructor(name, discount) {
    super(name); // call parent constructor
    this.discount = discount;
  }
  greet() {
    return `${super.greet()} You have ${this.discount}% discount!`;
  }
}

let customer1 = new Customer("Suraj");
let customer2 = new PremiumCustomer("Riya", 20);

console.log(customer1.greet()); // Hello, Suraj!
console.log(customer2.greet()); // Hello, Riya! You have 20% discount!


📌 Real Use Case: Different types of users in an e-commerce platform.

✅ Example 3: Encapsulation (Private Properties)
class BankAccount {
  #balance; // private property

  constructor(owner, balance) {
    this.owner = owner;
    this.#balance = balance;
  }

  deposit(amount) {
    this.#balance += amount;
    console.log(`₹${amount} deposited. Current balance: ₹${this.#balance}`);
  }

  getBalance() {
    return this.#balance;
  }
}

let account = new BankAccount("Suraj", 5000);
account.deposit(2000); // ₹2000 deposited. Current balance: ₹7000
console.log(account.getBalance()); // 7000
// console.log(account.#balance); // ❌ Error: Private property


📌 Real Use Case: Secure banking apps → hide sensitive data like balance.

✅ Example 4: Polymorphism (Multiple Behavior)
class Notification {
  send(message) {
    console.log(`Notification: ${message}`);
  }
}

class EmailNotification extends Notification {
  send(message) {
    console.log(`Email sent: ${message}`);
  }
}

class SMSNotification extends Notification {
  send(message) {
    console.log(`SMS sent: ${message}`);
  }
}

let notifications = [
  new Notification(),
  new EmailNotification(),
  new SMSNotification()
];

notifications.forEach(n => n.send("Your order is confirmed!"));


Output:

Notification: Your order is confirmed!
Email sent: Your order is confirmed!
SMS sent: Your order is confirmed!


📌 Real Use Case: Send notifications through multiple channels (Email, SMS, App).

⚡ Summary
OOP Concept	JS Feature	Real Use Case
Class & Object	class, new	Products, Orders
Inheritance	extends, super	Regular vs Premium Customer
Encapsulation	#private	Bank account balance
Polymorphism	Method overriding	Notifications via Email/SMS
Methods	Functions inside class	Order details, greetings

✅ Key Takeaways:

OOP in JS helps organize complex apps.

Classes & inheritance make code reusable & maintainable.

Private properties & encapsulation secure sensitive data.

=====================================================================
Constructor Functions
=====================================================================
🔹 1. What is a Constructor Function?

A constructor function is a special type of function used to create multiple objects with the same structure.

By convention, its name starts with a capital letter.

You use the new keyword to create objects from it.

🔹 2. Syntax
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.greet = function() {
    return `Hello, my name is ${this.name} and I am ${this.age} years old.`;
  };
}

let person1 = new Person("Suraj", 25);
let person2 = new Person("Riya", 24);

console.log(person1.greet());
console.log(person2.greet());


Output:

Hello, my name is Suraj and I am 25 years old.
Hello, my name is Riya and I am 24 years old.


📌 Real Use Case: Creating multiple user objects in a web app.

🔹 3. Example 1: Online Shopping Products
function Product(name, price, category) {
  this.name = name;
  this.price = price;
  this.category = category;
  this.getDetails = function() {
    return `${this.name} (${this.category}) costs ₹${this.price}`;
  };
}

let laptop = new Product("Laptop", 45000, "Electronics");
let phone = new Product("Phone", 15000, "Electronics");

console.log(laptop.getDetails()); // Laptop (Electronics) costs ₹45000
console.log(phone.getDetails());  // Phone (Electronics) costs ₹15000


📌 Real Use Case: E-commerce websites creating multiple product objects dynamically.

🔹 4. Example 2: Bank Accounts
function BankAccount(owner, balance) {
  this.owner = owner;
  this.balance = balance;
  
  this.deposit = function(amount) {
    this.balance += amount;
    return `₹${amount} deposited. Current balance: ₹${this.balance}`;
  };

  this.withdraw = function(amount) {
    if(amount > this.balance) return "Insufficient balance!";
    this.balance -= amount;
    return `₹${amount} withdrawn. Remaining balance: ₹${this.balance}`;
  };
}

let account1 = new BankAccount("Suraj", 5000);
console.log(account1.deposit(2000));   // ₹2000 deposited. Current balance: ₹7000
console.log(account1.withdraw(1000));  // ₹1000 withdrawn. Remaining balance: ₹6000


📌 Real Use Case: Banking apps to create multiple user accounts with methods.

🔹 5. Example 3: Employee Management
function Employee(name, position, salary) {
  this.name = name;
  this.position = position;
  this.salary = salary;

  this.getDetails = function() {
    return `${this.name} works as ${this.position} with a salary of ₹${this.salary}`;
  };
}

let emp1 = new Employee("Amit", "Developer", 50000);
let emp2 = new Employee("Sneha", "Designer", 45000);

console.log(emp1.getDetails()); // Amit works as Developer with a salary of ₹50000
console.log(emp2.getDetails()); // Sneha works as Designer with a salary of ₹45000


📌 Real Use Case: HR apps managing multiple employees.

🔹 6. Key Points
Feature	Description	Real Use Case
this keyword	Refers to the newly created object	Access object properties
new keyword	Creates a new instance	Generate multiple products/users
Methods inside function	Functions defined in constructor	Deposit, Withdraw, GetDetails

✅ Key Takeaways:

Constructor functions are pre-ES6 way of creating objects (before class).

Perfect for creating multiple objects with shared structure.

Can include methods and properties for each object.

=====================================================================
Prototypes & Prototype Chain
=====================================================================
🔹 1. What is a Prototype?

Every JavaScript object has a hidden prototype object.

The prototype contains properties and methods that other objects can inherit.

Helps in memory efficiency, because methods can be shared across all instances instead of being recreated.

🔹 2. Prototype Chain

When you access a property or method on an object:

JS first looks on the object itself.

If not found, it looks at the prototype.

This continues up the chain until it reaches Object.prototype.

If not found, returns undefined.

🔹 3. Real-Based Examples
✅ Example 1: Adding Methods to Prototype (Product)
function Product(name, price) {
  this.name = name;
  this.price = price;
}

// Adding method to prototype
Product.prototype.getDetails = function() {
  return `${this.name} costs ₹${this.price}`;
};

let laptop = new Product("Laptop", 45000);
let phone = new Product("Phone", 15000);

console.log(laptop.getDetails()); // Laptop costs ₹45000
console.log(phone.getDetails());  // Phone costs ₹15000


Explanation:

getDetails() is not created for every object, it lives in prototype.

Memory-efficient for many objects.

📌 Real Use Case: E-commerce apps → many products sharing common methods.

✅ Example 2: Inheritance via Prototype Chain (Customer & Premium Customer)
function Customer(name) {
  this.name = name;
}

Customer.prototype.greet = function() {
  return `Hello, ${this.name}!`;
};

// PremiumCustomer inherits Customer
function PremiumCustomer(name, discount) {
  Customer.call(this, name); // call parent constructor
  this.discount = discount;
}

PremiumCustomer.prototype = Object.create(Customer.prototype);
PremiumCustomer.prototype.constructor = PremiumCustomer;

PremiumCustomer.prototype.greet = function() {
  return `${Customer.prototype.greet.call(this)} You have ${this.discount}% discount!`;
};

let customer1 = new Customer("Suraj");
let customer2 = new PremiumCustomer("Riya", 20);

console.log(customer1.greet()); // Hello, Suraj!
console.log(customer2.greet()); // Hello, Riya! You have 20% discount!


Explanation:

PremiumCustomer inherits methods from Customer via prototype chain.

Can override methods (greet) → Polymorphism.

📌 Real Use Case: Different types of users in apps.

✅ Example 3: Checking Prototype Chain
console.log(laptop.__proto__ === Product.prototype); // true
console.log(Product.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__); // null


Explanation:

__proto__ shows the prototype of an object.

The chain ends at Object.prototype.

📌 Real Use Case: Debugging inheritance in large apps.

✅ Example 4: Prototype Methods for Shared Behavior (Bank Account)
function BankAccount(owner, balance) {
  this.owner = owner;
  this.balance = balance;
}

BankAccount.prototype.deposit = function(amount) {
  this.balance += amount;
  return `₹${amount} deposited. Current balance: ₹${this.balance}`;
};

BankAccount.prototype.withdraw = function(amount) {
  if(amount > this.balance) return "Insufficient balance!";
  this.balance -= amount;
  return `₹${amount} withdrawn. Remaining balance: ₹${this.balance}`;
};

let acc1 = new BankAccount("Suraj", 5000);
let acc2 = new BankAccount("Riya", 7000);

console.log(acc1.deposit(2000)); // ₹2000 deposited. Current balance: ₹7000
console.log(acc2.withdraw(3000)); // ₹3000 withdrawn. Remaining balance: ₹4000


📌 Real Use Case: Banking apps → multiple accounts sharing common operations.

⚡ Summary
Concept	Description	Real Use Case
Prototype	Object containing shared properties/methods	Product methods, Bank operations
Prototype Chain	Inheritance chain of objects	Customer → PremiumCustomer
Object.create()	Create new object with specific prototype	Inheritance setup
Memory Efficiency	Methods on prototype shared by all instances	Avoid recreating functions for each object
Method Overriding	Child can override parent method	Premium customer discount

✅ Key Takeaways:

Prototypes allow shared methods → saves memory.

Prototype chain enables inheritance and method lookup.

Essential for understanding JS OOP under the hood.

=====================================================================
class & extends
=====================================================================
🔹 1. What is a Class in JavaScript?

A class is a blueprint to create objects with properties and methods.

Introduced in ES6.

Syntax is cleaner than constructor functions.

🔹 2. What is extends?

extends is used for inheritance.

A child class can inherit properties and methods from a parent class.

Use super() to call the parent constructor.

🔹 3. Real-Based Examples
✅ Example 1: Classes & Objects (E-commerce Product)
class Product {
  constructor(name, price, category) {
    this.name = name;
    this.price = price;
    this.category = category;
  }

  getDetails() {
    return `${this.name} (${this.category}) costs ₹${this.price}`;
  }
}

let laptop = new Product("Laptop", 45000, "Electronics");
let phone = new Product("Phone", 15000, "Electronics");

console.log(laptop.getDetails()); // Laptop (Electronics) costs ₹45000
console.log(phone.getDetails());  // Phone (Electronics) costs ₹15000


📌 Real Use Case: Represent products in an e-commerce app.

✅ Example 2: Inheritance with extends (Customer & Premium Customer)
class Customer {
  constructor(name) {
    this.name = name;
  }

  greet() {
    return `Hello, ${this.name}!`;
  }
}

// PremiumCustomer inherits Customer
class PremiumCustomer extends Customer {
  constructor(name, discount) {
    super(name); // call parent constructor
    this.discount = discount;
  }

  greet() {
    return `${super.greet()} You have ${this.discount}% discount!`;
  }
}

let customer1 = new Customer("Suraj");
let customer2 = new PremiumCustomer("Riya", 20);

console.log(customer1.greet()); // Hello, Suraj!
console.log(customer2.greet()); // Hello, Riya! You have 20% discount!


📌 Real Use Case: Different types of users in an online store.

✅ Example 3: Banking System (Encapsulation & Inheritance)
class BankAccount {
  #balance; // private property

  constructor(owner, balance) {
    this.owner = owner;
    this.#balance = balance;
  }

  deposit(amount) {
    this.#balance += amount;
    return `₹${amount} deposited. Current balance: ₹${this.#balance}`;
  }

  getBalance() {
    return this.#balance;
  }
}

// Child class for special account
class SavingsAccount extends BankAccount {
  constructor(owner, balance, interestRate) {
    super(owner, balance);
    this.interestRate = interestRate;
  }

  calculateInterest() {
    return this.getBalance() * (this.interestRate / 100);
  }
}

let acc = new SavingsAccount("Suraj", 5000, 5);
console.log(acc.deposit(2000));        // ₹2000 deposited. Current balance: ₹7000
console.log(acc.calculateInterest());  // 350 (5% of 7000)


📌 Real Use Case: Banking app → savings account with interest calculation.

✅ Example 4: Polymorphism with Classes
class Notification {
  send(message) {
    console.log(`Notification: ${message}`);
  }
}

class EmailNotification extends Notification {
  send(message) {
    console.log(`Email sent: ${message}`);
  }
}

class SMSNotification extends Notification {
  send(message) {
    console.log(`SMS sent: ${message}`);
  }
}

let notifications = [
  new Notification(),
  new EmailNotification(),
  new SMSNotification()
];

notifications.forEach(n => n.send("Your order is confirmed!"));


Output:

Notification: Your order is confirmed!
Email sent: Your order is confirmed!
SMS sent: Your order is confirmed!


📌 Real Use Case: Send notifications through multiple channels.

⚡ Summary
Feature	JS Syntax	Real Use Case
Class	class	Products, Orders, Employees
Constructor	constructor()	Initialize object properties
Method	methodName()	Get product details, deposit money
Inheritance	extends	Customer → PremiumCustomer
Super Constructor	super()	Call parent constructor
Polymorphism	Method overriding	Notifications via Email/SMS
Encapsulation	#privateProperty	Bank balance, secure data

✅ Key Takeaways:

Classes make OOP in JS cleaner than constructor functions.

extends enables inheritance and method reuse.

Use polymorphism & encapsulation for real-world apps like e-commerce, banking, or notifications.

=====================================================================
super & constructor
=====================================================================
🔹 1. constructor in JS

The constructor is a special method inside a class used to initialize object properties.

Every class can have one constructor.

If you don’t define one, JS provides a default constructor.

🔹 2. super in JS

super is used in child classes to:

Call the parent class constructor

Access parent class methods

Must be called in child constructor before using this.

🔹 3. Real-Based Examples
✅ Example 1: Basic Constructor
class Product {
  constructor(name, price) {
    this.name = name;
    this.price = price;
  }

  getDetails() {
    return `${this.name} costs ₹${this.price}`;
  }
}

let laptop = new Product("Laptop", 45000);
console.log(laptop.getDetails()); // Laptop costs ₹45000


📌 Real Use Case: Create multiple products in an e-commerce platform.

✅ Example 2: super in Child Class (Customer & PremiumCustomer)
class Customer {
  constructor(name) {
    this.name = name;
  }

  greet() {
    return `Hello, ${this.name}!`;
  }
}

class PremiumCustomer extends Customer {
  constructor(name, discount) {
    super(name); // call parent constructor
    this.discount = discount;
  }

  greet() {
    return `${super.greet()} You have ${this.discount}% discount!`;
  }
}

let customer1 = new PremiumCustomer("Riya", 20);
console.log(customer1.greet()); // Hello, Riya! You have 20% discount!


Explanation:

super(name) → calls Customer constructor to set name.

super.greet() → calls parent method inside child method.

📌 Real Use Case: Different types of users with shared properties & customized methods.

✅ Example 3: Banking System (Constructor + Super)
class BankAccount {
  constructor(owner, balance) {
    this.owner = owner;
    this.balance = balance;
  }

  getBalance() {
    return `Balance: ₹${this.balance}`;
  }
}

class SavingsAccount extends BankAccount {
  constructor(owner, balance, interestRate) {
    super(owner, balance); // call parent constructor
    this.interestRate = interestRate;
  }

  calculateInterest() {
    return this.balance * (this.interestRate / 100);
  }
}

let acc = new SavingsAccount("Suraj", 5000, 5);
console.log(acc.getBalance());       // Balance: ₹5000
console.log(acc.calculateInterest()); // 250


📌 Real Use Case: Child account class extends base account with extra features like interest.

✅ Example 4: Polymorphism with super
class Notification {
  constructor(sender) {
    this.sender = sender;
  }

  send(message) {
    console.log(`${this.sender} says: ${message}`);
  }
}

class EmailNotification extends Notification {
  send(message) {
    super.send(message); // call parent send()
    console.log(`Email sent: ${message}`);
  }
}

let email = new EmailNotification("System");
email.send("Your order is confirmed!");


Output:

System says: Your order is confirmed!
Email sent: Your order is confirmed!


📌 Real Use Case: Multi-channel notifications (parent method + extra child behavior).

⚡ Summary
Feature	Description	Real Use Case
constructor	Initialize object properties	Product, BankAccount
super()	Call parent constructor	Child class inheritance
super.method()	Call parent class method	Polymorphism in notifications
Usage Rule	Call super() before using this in child	Mandatory in JS

✅ Key Takeaways:

constructor → sets up object data when creating instance.

super → links child to parent for shared properties and methods.

Essential for OOP with classes, inheritance, and polymorphism.

=====================================================================
Encapsulation, Inheritance, Polymorphism
=====================================================================
🔹 1. Encapsulation

Encapsulation is the concept of hiding internal data of an object and controlling access through methods.

In JS (ES6+), we use private properties with # and getter/setter methods.

✅ Real-Based Example: Bank Account
class BankAccount {
  #balance; // private property

  constructor(owner, balance) {
    this.owner = owner;
    this.#balance = balance;
  }

  deposit(amount) {
    this.#balance += amount;
    console.log(`₹${amount} deposited. Current balance: ₹${this.#balance}`);
  }

  withdraw(amount) {
    if(amount > this.#balance) {
      console.log("Insufficient balance!");
    } else {
      this.#balance -= amount;
      console.log(`₹${amount} withdrawn. Remaining balance: ₹${this.#balance}`);
    }
  }

  getBalance() {
    return this.#balance;
  }
}

let acc = new BankAccount("Suraj", 5000);
acc.deposit(2000);       // ₹2000 deposited. Current balance: ₹7000
acc.withdraw(1000);      // ₹1000 withdrawn. Remaining balance: ₹6000
console.log(acc.getBalance()); // 6000
// console.log(acc.#balance); // ❌ Error: Private property


📌 Real Use Case: Banking app → keep balance safe from direct access.

🔹 2. Inheritance

Inheritance allows a child class to reuse properties and methods from a parent class.

Use extends and super() in JS.

✅ Real-Based Example: Customer & Premium Customer
class Customer {
  constructor(name) {
    this.name = name;
  }

  greet() {
    return `Hello, ${this.name}!`;
  }
}

class PremiumCustomer extends Customer {
  constructor(name, discount) {
    super(name); // call parent constructor
    this.discount = discount;
  }

  greet() {
    return `${super.greet()} You have ${this.discount}% discount!`;
  }
}

let c1 = new Customer("Suraj");
let c2 = new PremiumCustomer("Riya", 20);

console.log(c1.greet()); // Hello, Suraj!
console.log(c2.greet()); // Hello, Riya! You have 20% discount!


📌 Real Use Case: Different types of users with shared properties and customized behavior.

🔹 3. Polymorphism

Polymorphism means same method behaves differently depending on the object.

Achieved by method overriding in child classes.

✅ Real-Based Example: Notifications
class Notification {
  send(message) {
    console.log(`Notification: ${message}`);
  }
}

class EmailNotification extends Notification {
  send(message) {
    console.log(`Email sent: ${message}`);
  }
}

class SMSNotification extends Notification {
  send(message) {
    console.log(`SMS sent: ${message}`);
  }
}

let notifications = [
  new Notification(),
  new EmailNotification(),
  new SMSNotification()
];

notifications.forEach(n => n.send("Your order is confirmed!"));


Output:

Notification: Your order is confirmed!
Email sent: Your order is confirmed!
SMS sent: Your order is confirmed!


📌 Real Use Case: Multi-channel notifications system (parent + child behavior).

🔹 4. Full Real-Based Example (Banking System)
class BankAccount {
  #balance;
  constructor(owner, balance) {
    this.owner = owner;
    this.#balance = balance;
  }
  deposit(amount) { this.#balance += amount; }
  withdraw(amount) { this.#balance -= amount; }
  getBalance() { return this.#balance; }
}

class SavingsAccount extends BankAccount {
  constructor(owner, balance, interestRate) {
    super(owner, balance);
    this.interestRate = interestRate;
  }
  calculateInterest() { return this.getBalance() * (this.interestRate / 100); }
}

class CurrentAccount extends BankAccount {
  constructor(owner, balance, overdraftLimit) {
    super(owner, balance);
    this.overdraftLimit = overdraftLimit;
  }
  withdraw(amount) {
    if(amount > this.getBalance() + this.overdraftLimit) {
      console.log("Exceeded overdraft limit!");
    } else {
      super.withdraw(amount);
      console.log(`₹${amount} withdrawn. Remaining balance: ₹${this.getBalance()}`);
    }
  }
}

let sAcc = new SavingsAccount("Suraj", 5000, 5);
console.log(sAcc.calculateInterest()); // 250

let cAcc = new CurrentAccount("Riya", 3000, 1000);
cAcc.withdraw(3500); // ₹3500 withdrawn. Remaining balance: ₹-500
cAcc.withdraw(5000); // Exceeded overdraft limit!


✅ What’s Demonstrated:

Encapsulation → #balance private.

Inheritance → SavingsAccount & CurrentAccount inherit BankAccount.

Polymorphism → CurrentAccount overrides withdraw method.

⚡ Summary
Concept	JS Feature	Real Use Case
Encapsulation	#private, getter/setter	Secure bank balance
Inheritance	extends, super()	Customer → PremiumCustomer
Polymorphism	Method overriding	Notifications, Custom withdraw

=====================================================================
Object.create()
=====================================================================
🔹 1. What is Object.create()?

Object.create() is a method to create a new object using an existing object as its prototype.

Useful for prototypal inheritance without using classes or constructor functions.

Syntax:

let newObj = Object.create(protoObj);


protoObj → The object to be used as the prototype of the new object.

🔹 2. Real-Based Examples
✅ Example 1: Basic Object Inheritance
const productProto = {
  getDetails: function() {
    return `${this.name} costs ₹${this.price}`;
  }
};

const laptop = Object.create(productProto);
laptop.name = "Laptop";
laptop.price = 45000;

const phone = Object.create(productProto);
phone.name = "Phone";
phone.price = 15000;

console.log(laptop.getDetails()); // Laptop costs ₹45000
console.log(phone.getDetails());  // Phone costs ₹15000


📌 Real Use Case: E-commerce app → multiple products sharing common methods.

✅ Example 2: Banking System (Prototype Inheritance)
const bankAccountProto = {
  deposit: function(amount) {
    this.balance += amount;
    console.log(`₹${amount} deposited. Current balance: ₹${this.balance}`);
  },
  withdraw: function(amount) {
    if(amount > this.balance) console.log("Insufficient balance!");
    else {
      this.balance -= amount;
      console.log(`₹${amount} withdrawn. Remaining balance: ₹${this.balance}`);
    }
  }
};

const acc1 = Object.create(bankAccountProto);
acc1.owner = "Suraj";
acc1.balance = 5000;

const acc2 = Object.create(bankAccountProto);
acc2.owner = "Riya";
acc2.balance = 7000;

acc1.deposit(2000);  // ₹2000 deposited. Current balance: ₹7000
acc2.withdraw(3000); // ₹3000 withdrawn. Remaining balance: ₹4000


📌 Real Use Case: Multiple bank accounts sharing deposit/withdraw functionality.

✅ Example 3: Inheritance Chain
const customerProto = {
  greet: function() {
    return `Hello, ${this.name}!`;
  }
};

const premiumCustomerProto = Object.create(customerProto);
premiumCustomerProto.greet = function() {
  return `${customerProto.greet.call(this)} You have ${this.discount}% discount!`;
};

const customer1 = Object.create(customerProto);
customer1.name = "Suraj";

const customer2 = Object.create(premiumCustomerProto);
customer2.name = "Riya";
customer2.discount = 20;

console.log(customer1.greet()); // Hello, Suraj!
console.log(customer2.greet()); // Hello, Riya! You have 20% discount!


📌 Real Use Case: Customer system → Regular & Premium customers sharing behavior through prototypes.

✅ Example 4: Shared Methods Without Classes
const notificationProto = {
  send: function(message) {
    console.log(`Notification: ${message}`);
  }
};

const emailNotification = Object.create(notificationProto);
emailNotification.send = function(message) {
  console.log(`Email sent: ${message}`);
};

const smsNotification = Object.create(notificationProto);
smsNotification.send = function(message) {
  console.log(`SMS sent: ${message}`);
};

emailNotification.send("Order confirmed!"); // Email sent: Order confirmed!
smsNotification.send("Order confirmed!");   // SMS sent: Order confirmed!


📌 Real Use Case: Multi-channel notifications without classes.

⚡ Summary
Feature	Description	Real Use Case
Object.create(proto)	Creates object with specified prototype	Products, Bank Accounts
Prototypal Inheritance	Methods shared across multiple objects	Customer → PremiumCustomer
Memory Efficient	Methods stored on prototype, not instance	Notifications, Banking system
Alternative to Classes	Simple inheritance without ES6 class	Lightweight apps, utility objects

✅ Key Takeaways:

Object.create() is a powerful tool for prototypal inheritance.

Allows shared methods without using classes or constructor functions.

Great for memory-efficient, real-world apps like e-commerce, banking, and notification systems.


===================================================================
🔵 9. Functional Programming

Pure Functions

Immutability

First-class Functions

Higher-Order Functions

Currying & Partial Application

Composition & Pipelines

🟢 10. Browser APIs

LocalStorage & SessionStorage

Geolocation API

Fetch & API Calls

Web Workers

Canvas API

Notifications & Clipboard API

🟡 11. Asynchronous JavaScript (Deep Dive)

Callbacks

Promises (chaining)

Async/Await with try...catch

Parallel vs Sequential Execution

Promise.all, Promise.race, Promise.any

🔴 12. Advanced Topics

Event Bubbling vs Capturing

Debouncing & Throttling

Modules (ESM vs CommonJS)

Polyfills & Transpilers (Babel)

Bundlers (Webpack, Vite, Parcel)

Error Handling & Debugging (console, debugger)

===================================================================

















